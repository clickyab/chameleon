/**
 * The clickyab.com/crab API
 * The crab api, auto generated
 *
 * OpenAPI spec version: \"0.0.1-pre-alpha\"
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import AAA from "./../services/AAA/index";
import * as querystring from "querystring";
import * as url from "url";
import * as assign from "core-js/library/fn/object/assign";
import "whatwg-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

export const BASE_PATH = "http://staging.crab.clickyab.ae/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    configuration: object;

    constructor(fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH, configuration: object = {}) {
        this.basePath = basePath;
        this.fetch = fetchFn;
        this.configuration = configuration;
    }
}

export interface ControllerErrorResponseSimple {
    "error"?: NotAuthorizedError;
}

export interface ControllerNormalResponse {
}

export interface ControllersBrowserResponse extends Array<ControllersBrowserResponseInner> {
}

export interface ControllersBrowserResponseInner {
    "active"?: boolean;
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface ControllersCatResponse extends Array<ControllersCatResponseInner> {
}

export interface ControllersCatResponseInner {
    "description"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
}

export interface ControllersIspResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersIspResponseInner {
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
    "updated_at"?: string;
}

export interface ControllersListPublisherDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListPublisherDefResponseColumns>;
    "hash"?: string;
    "multiselect"?: boolean;
}

export interface ControllersListPublisherDefResponseColumns {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface ControllersListPublisherResponse {
    "data"?: Array<ControllersListPublisherResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListPublisherResponseData {
    "_actions"?: string;
    "created_at"?: string;
    "domain"?: string;
    "id"?: number;
    "name"?: string;
    "pub_type"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersManufacturers extends Array<ControllersManufacturersInner> {
}

export interface ControllersManufacturersInner {
    "active"?: boolean;
    "brand"?: string;
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface ControllersOsResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersWhiteBlackList {
    "domains"?: Array<string>;
    "kind"?: boolean;
    "label"?: string;
    "publisher_type"?: string;
}

export interface ControllersWhiteBlackLists extends Array<ControllersWhiteBlackListsInner> {
}

export interface ControllersWhiteBlackListsInner {
    "active"?: boolean;
    "created_at"?: string;
    "domains"?: Array<string>;
    "id"?: number;
    "kind"?: boolean;
    "label"?: string;
    "publisher_type"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface DmnDomain {
    "active"?: boolean;
    "created_at"?: string;
    "description"?: DmnDomainDescription;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface DmnDomainDescription {
    "String"?: string;
    "Valid"?: boolean;
}

export interface LocationCities extends Array<LocationCitiesInner> {
}

export interface LocationCitiesInner {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCity {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCountries extends Array<LocationCountriesInner> {
}

export interface LocationCountriesInner {
    "id"?: number;
    "name"?: string;
}

export interface LocationCountry {
    "id"?: number;
    "name"?: string;
}

export interface LocationProvince {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface LocationProvinces extends Array<LocationProvincesInner> {
}

export interface LocationProvincesInner {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface NotAuthorized {
    "error"?: NotAuthorizedError;
}

export interface NotAuthorizedError {
    "params"?: Array<string>;
    "text"?: string;
}

export interface OrmBase {
    "active"?: boolean;
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface OrmBrowser {
    "active"?: boolean;
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface OrmCategory {
    "description"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
}

export interface OrmISP {
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
    "updated_at"?: string;
}

export interface OrmManufacturer {
    "active"?: boolean;
    "brand"?: string;
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface OrmOS {
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
    "updated_at"?: string;
}

export interface OrmPublisherType {
}

export interface OrmWhiteBlackList {
    "active"?: boolean;
    "created_at"?: string;
    "domains"?: Array<string>;
    "id"?: number;
    "kind"?: boolean;
    "label"?: string;
    "publisher_type"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface PermissionColumn {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface PubPubType {
}

export interface PubPublisher {
    "created_at"?: string;
    "domain"?: string;
    "id"?: number;
    "name"?: string;
    "pub_type"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface PubPublisherDataTable {
    "_actions"?: string;
    "created_at"?: string;
    "domain"?: string;
    "id"?: number;
    "name"?: string;
    "pub_type"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface PubStatus {
}

export interface TransT9Base {
    "params"?: Array<string>;
    "text"?: string;
}

export interface UserCallBackPayload {
    "new_password"?: string;
}

export interface UserChangePassword {
    "current_password"?: string;
    "new_password"?: string;
}

export interface UserCheckMailPayload {
    "email"?: string;
}

export interface UserCheckMailResponse {
    "current_domain"?: boolean;
    "domains"?: Array<UserCheckMailResponseDomains>;
}

export interface UserCheckMailResponseDomains {
    "active"?: boolean;
    "created_at"?: string;
    "description"?: DmnDomainDescription;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface UserForgetPayload {
    "email"?: string;
}

export interface UserLoginPayload {
    "email"?: string;
    "password"?: string;
}

export interface UserRegisterPayload {
    "email"?: string;
    "first_name"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "mobile"?: string;
    "password"?: string;
}

export interface UserResponseLoginOK {
    "account"?: UserResponseLoginOKAccount;
    "token"?: string;
}

export interface UserResponseLoginOKAccount {
    "address"?: string;
    "avatar"?: string;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserUserPayload {
    "address"?: string;
    "avatar"?: string;
    "cell_phone"?: string;
    "city_id"?: number;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "ssn"?: string;
}

export interface UserUserResponse {
    "address"?: string;
    "avatar"?: string;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserVerifyIdResponse {
    "account"?: UserResponseLoginOKAccount;
    "token"?: string;
}

export interface UserVerifyResendPayload {
    "email_string"?: string;
}



/**
 * ControllersApi - fetch parameter creator
 */
export const ControllersApiFetchParamCreator = {
    /**
     * @func
     * assetBrowserGet
     * @param token the security token, get it from login route param
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/browser`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetCategoryGet
     * @param token the security token, get it from login route param
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/category`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetIspGet
     * @param token the security token, get it from login route param
     */
    assetIspGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/isp`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetManufacturersGet
     * @param token the security token, get it from login route param
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/manufacturers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsGet
     * @param token the security token, get it from login route param
     */
    assetOsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPresetIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/preset/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/preset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetsGet
     * @param token the security token, get it from login route param
     */
    inventoryPresetsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/presets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * publisherListDefinitionGet
     * @param token the security token, get it from login route param
     */
    publisherListDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/publisher/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * publisherListGet
     * @param token the security token, get it from login route param
     * @param status  param
     * @param domain  search the domain field param
     * @param c  count per page param
     * @param p  page number param
     * @param pubType  param
     */
    publisherListGet(params: {  token?: string; status?: string; domain?: string; c?: string; p?: string; pubType?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/publisher/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["pubType"] !== undefined) {
            urlObj.query["pub_type"] = params["pubType"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadModulePost
     * @param module  param
     * @param token the security token, get it from login route param
     */
    uploadModulePost(params: {  module: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "module" is set
        if (params["module"] == null) {
            throw new Error("Missing required parameter module when calling uploadModulePost");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/{module}`
            .replace(`{${"module"}}`, `${ params["module"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ControllersApi - functional programming interface
 */
export const ControllersApiFp = {
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBrowserResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetBrowserGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCatResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetCategoryGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetIspGet
     * @param token the security token, get it from login route (def)
     */
    assetIspGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersIspResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetIspGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersManufacturers> {
        const fetchArgs = ControllersApiFetchParamCreator.assetManufacturersGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetOsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmWhiteBlackList> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryPresetPost(params: { token?: string; payloadData?: ControllersWhiteBlackList;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmWhiteBlackList> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetsGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersWhiteBlackLists> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * publisherListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    publisherListDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.publisherListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * publisherListGet
     * @param token the security token, get it from login route (def)
     * @param status  (def)
     * @param domain  search the domain field (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param pubType  (def)
     */
    publisherListGet(params: { token?: string; status?: string; domain?: string; c?: string; p?: string; pubType?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.publisherListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModulePost(params: { module: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadModulePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * ControllersApi - object-oriented interface
 */
export class ControllersApi extends BaseAPI {
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetBrowserGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetCategoryGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetIspGet
     * @param token the security token, get it from login route (def)
     */
    assetIspGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetIspGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetManufacturersGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetsGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * publisherListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    publisherListDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.publisherListDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * publisherListGet
     * @param token the security token, get it from login route (def)
     * @param status  (def)
     * @param domain  search the domain field (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param pubType  (def)
     */
    publisherListGet(params: {  token?: string; status?: string; domain?: string; c?: string; p?: string; pubType?: string; }, options: any = {}) {
        return ControllersApiFp.publisherListGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModulePost(params: {  module: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadModulePost(params, options)(this.fetch, this.basePath);
    }
}

/**
 * ControllersApi - factory interface
 */
export const ControllersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * assetBrowserGet
         * @param token the security token, get it from login route (def)
         */
        assetBrowserGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetBrowserGet(params, options)(fetch, basePath);
        },
        /**
         * assetCategoryGet
         * @param token the security token, get it from login route (def)
         */
        assetCategoryGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetCategoryGet(params, options)(fetch, basePath);
        },
        /**
         * assetIspGet
         * @param token the security token, get it from login route (def)
         */
        assetIspGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetIspGet(params, options)(fetch, basePath);
        },
        /**
         * assetManufacturersGet
         * @param token the security token, get it from login route (def)
         */
        assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetManufacturersGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsGet
         * @param token the security token, get it from login route (def)
         */
        assetOsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetIdGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetPost(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetsGet
         * @param token the security token, get it from login route (def)
         */
        inventoryPresetsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetsGet(params, options)(fetch, basePath);
        },
        /**
         * publisherListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        publisherListDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.publisherListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * publisherListGet
         * @param token the security token, get it from login route (def)
         * @param status  (def)
         * @param domain  search the domain field (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param pubType  (def)
         */
        publisherListGet(params: {  token?: string; status?: string; domain?: string; c?: string; p?: string; pubType?: string; }, options: any = {}) {
            return ControllersApiFp.publisherListGet(params, options)(fetch, basePath);
        },
        /**
         * uploadModulePost
         * @param module  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadModulePost(params: {  module: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadModulePost(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationApi - fetch parameter creator
 */
export const LocationApiFetchParamCreator = {
    /**
     * @func
     * locationCitiesProvincesIdGet
     * @param provincesId  param
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "provincesId" is set
        if (params["provincesId"] == null) {
            throw new Error("Missing required parameter provincesId when calling locationCitiesProvincesIdGet");
        }
        const baseUrl = `/location/cities/{provinces_id}`
            .replace(`{${"provinces_id"}}`, `${ params["provincesId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationProvincesCountryIdGet
     * @param countryId  param
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryId" is set
        if (params["countryId"] == null) {
            throw new Error("Missing required parameter countryId when calling locationProvincesCountryIdGet");
        }
        const baseUrl = `/location/provinces/{country_id}`
            .replace(`{${"country_id"}}`, `${ params["countryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: { provincesId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCities> {
        const fetchArgs = LocationApiFetchParamCreator.locationCitiesProvincesIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCountries> {
        const fetchArgs = LocationApiFetchParamCreator.locationCountriesGet(options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: { countryId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationProvinces> {
        const fetchArgs = LocationApiFetchParamCreator.locationProvincesCountryIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
        return LocationApiFp.locationCitiesProvincesIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}) {
        return LocationApiFp.locationCountriesGet(options)(this.fetch, this.basePath);
    }
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
        return LocationApiFp.locationProvincesCountryIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * locationCitiesProvincesIdGet
         * @param provincesId  (def)
         */
        locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
            return LocationApiFp.locationCitiesProvincesIdGet(params, options)(fetch, basePath);
        },
        /**
         * locationCountriesGet
         */
        locationCountriesGet(options: any = {}) {
            return LocationApiFp.locationCountriesGet(options)(fetch, basePath);
        },
        /**
         * locationProvincesCountryIdGet
         * @param countryId  (def)
         */
        locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
            return LocationApiFp.locationProvincesCountryIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * @func
     * userEmailVerifyResendPost
     * @param payloadData  param
     */
    userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify/resend`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyTokenGet
     * @param token  param
     */
    userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/email/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLoginPost
     * @param payloadData  param
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route param
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout/closeother`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutGet
     * @param token the security token, get it from login route param
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userMailCheckPost
     * @param payloadData  param
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/mail/check`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangeTokenPut
     * @param token  param
     * @param payloadData  param
     */
    userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordForgetPost
     * @param payloadData  param
     */
    userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/forget`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyTokenGet
     * @param token  param
     */
    userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPingGet
     * @param token the security token, get it from login route param
     */
    userPingGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/ping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userRegisterPost
     * @param payloadData  param
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userUpdatePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/update`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyResendPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserVerifyIdResponse> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: { payloadData?: UserLoginPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLoginPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutCloseotherGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserCheckMailResponse> {
        const fetchArgs = UserApiFetchParamCreator.userMailCheckPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangeTokenPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: { payloadData?: UserForgetPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordForgetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPingGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userRegisterPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: { token?: string; payloadData?: UserUserPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userUpdatePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyResendPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userEmailVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
        return UserApiFp.userLoginPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutCloseotherGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
        return UserApiFp.userMailCheckPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
        return UserApiFp.userPasswordChangePut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
        return UserApiFp.userPasswordChangeTokenPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}) {
        return UserApiFp.userPasswordForgetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPingGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
        return UserApiFp.userRegisterPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
        return UserApiFp.userUpdatePut(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * userEmailVerifyResendPost
         * @param payloadData  (def)
         */
        userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyResendPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyTokenGet
         * @param token  (def)
         */
        userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userEmailVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userLoginPost
         * @param payloadData  (def)
         */
        userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
            return UserApiFp.userLoginPost(params, options)(fetch, basePath);
        },
        /**
         * userLogoutCloseotherGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutCloseotherGet(params, options)(fetch, basePath);
        },
        /**
         * userLogoutGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutGet(params, options)(fetch, basePath);
        },
        /**
         * userMailCheckPost
         * @param payloadData  (def)
         */
        userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
            return UserApiFp.userMailCheckPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
            return UserApiFp.userPasswordChangePut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangeTokenPut
         * @param token  (def)
         * @param payloadData  (def)
         */
        userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
            return UserApiFp.userPasswordChangeTokenPut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordForgetPost
         * @param payloadData  (def)
         */
        userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}) {
            return UserApiFp.userPasswordForgetPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyTokenGet
         * @param token  (def)
         */
        userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userPingGet
         * @param token the security token, get it from login route (def)
         */
        userPingGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPingGet(params, options)(fetch, basePath);
        },
        /**
         * userRegisterPost
         * @param payloadData  (def)
         */
        userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
            return UserApiFp.userRegisterPost(params, options)(fetch, basePath);
        },
        /**
         * userUpdatePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
            return UserApiFp.userUpdatePut(params, options)(fetch, basePath);
        },
    };
};

