/**
 * The clickyab.com/crab API
 * The crab api, auto generated
 *
 * OpenAPI spec version: \"0.0.1-pre-alpha\"
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import AAA from "./../services/AAA/index";
import * as querystring from "querystring";
import * as url from "url";
import * as assign from "core-js/library/fn/object/assign";
import "whatwg-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://staging.crab.clickyab.ae/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    configuration: object;

    constructor(fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH, configuration: object = {}) {
        this.basePath = basePath;
        this.fetch = fetchFn;
        this.configuration = configuration;
    }
}

export interface ControllerErrorResponseSimple {
    "error"?: NotAuthorizedError;
}

export interface ControllerNormalResponse {
}

export interface ControllersBrowserResponse extends Array<ControllersBrowserResponseInner> {
}

export interface ControllersBrowserResponseInner {
    "active"?: boolean;
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface ControllersCatResponse extends Array<ControllersCatResponseInner> {
}

export interface ControllersCatResponseInner {
    "description"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
}

export interface ControllersIspResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersIspResponseInner {
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
    "updated_at"?: string;
}

export interface ControllersManufacturers extends Array<ControllersManufacturersInner> {
}

export interface ControllersManufacturersInner {
    "active"?: boolean;
    "brand"?: string;
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface ControllersOsResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersWhiteBlackList {
    "domains"?: Array<string>;
    "kind"?: boolean;
    "label"?: string;
    "publisher_type"?: string;
}

export interface ControllersWhiteBlackLists extends Array<ControllersWhiteBlackListsInner> {
}

export interface ControllersWhiteBlackListsInner {
    "active"?: boolean;
    "created_at"?: string;
    "domains"?: Array<string>;
    "id"?: number;
    "kind"?: boolean;
    "label"?: string;
    "publisher_type"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface DmnActiveStatus {
}

export interface DmnDomain {
    "active"?: string;
    "created_at"?: string;
    "description"?: DmnDomainDescription;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface DmnDomainDescription {
    "String"?: string;
    "Valid"?: boolean;
}

export interface LocationCities extends Array<LocationCitiesInner> {
}

export interface LocationCitiesInner {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCity {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCountries extends Array<LocationCountriesInner> {
}

export interface LocationCountriesInner {
    "id"?: number;
    "name"?: string;
}

export interface LocationCountry {
    "id"?: number;
    "name"?: string;
}

export interface LocationProvince {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface LocationProvinces extends Array<LocationProvincesInner> {
}

export interface LocationProvincesInner {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface NotAuthorized {
    "error"?: NotAuthorizedError;
}

export interface NotAuthorizedError {
    "params"?: Array<string>;
    "text"?: string;
}

export interface OrmBase {
    "active"?: boolean;
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface OrmBrowser {
    "active"?: boolean;
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface OrmCategory {
    "description"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
}

export interface OrmISP {
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
    "updated_at"?: string;
}

export interface OrmManufacturer {
    "active"?: boolean;
    "brand"?: string;
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface OrmOS {
    "created_at"?: string;
    "id"?: number;
    "name"?: string;
    "status"?: boolean;
    "updated_at"?: string;
}

export interface OrmPublisherType {
}

export interface OrmWhiteBlackList {
    "active"?: boolean;
    "created_at"?: string;
    "domains"?: Array<string>;
    "id"?: number;
    "kind"?: boolean;
    "label"?: string;
    "publisher_type"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface TransT9Base {
    "params"?: Array<string>;
    "text"?: string;
}

export interface UserCallBack {
    "new_password"?: string;
    "token"?: string;
}

export interface UserChangePassword {
    "current_password"?: string;
    "new_password"?: string;
}

export interface UserCheckActivePayload {
    "email"?: string;
    "number"?: number;
}

export interface UserCheckMailPayload {
    "email"?: string;
}

export interface UserCheckMailResponse {
    "current_domain"?: boolean;
    "domains"?: Array<UserCheckMailResponseDomains>;
}

export interface UserCheckMailResponseDomains {
    "active"?: string;
    "created_at"?: string;
    "description"?: DmnDomainDescription;
    "id"?: number;
    "name"?: string;
    "updated_at"?: string;
}

export interface UserForget {
    "email"?: string;
}

export interface UserLoginPayload {
    "email"?: string;
    "password"?: string;
}

export interface UserRegisterPayload {
    "email"?: string;
    "first_name"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "mobile"?: string;
    "password"?: string;
}

export interface UserResponseLoginOK {
    "account"?: UserResponseLoginOKAccount;
    "token"?: string;
}

export interface UserResponseLoginOKAccount {
    "address"?: string;
    "avatar"?: string;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserSendActivePayload {
    "email"?: string;
}

export interface UserUserPayload {
    "address"?: string;
    "avatar"?: string;
    "cell_phone"?: string;
    "city_id"?: number;
    "corporation"?: UserUserPayloadCorporation;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "land_line"?: string;
    "last_name"?: string;
    "postal_code"?: string;
    "ssn"?: string;
}

export interface UserUserPayloadCorporation {
    "economic_code"?: DmnDomainDescription;
    "id"?: number;
    "legal_name"?: string;
    "legal_register"?: DmnDomainDescription;
    "user_id"?: number;
}

export interface UserUserResponse {
    "address"?: string;
    "avatar"?: string;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}



/**
 * ControllersApi - fetch parameter creator
 */
export const ControllersApiFetchParamCreator = {
    /**
     * @func
     * assetBrowserGet
     * @param token the security token, get it from login route param
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/browser`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetCategoryGet
     * @param token the security token, get it from login route param
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/category`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetIspGet
     * @param token the security token, get it from login route param
     */
    assetIspGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/isp`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetManufacturersGet
     * @param token the security token, get it from login route param
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/manufacturers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsGet
     * @param token the security token, get it from login route param
     */
    assetOsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPresetIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/preset/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/preset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetsGet
     * @param token the security token, get it from login route param
     */
    inventoryPresetsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/presets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadModulePost
     * @param module  param
     * @param token the security token, get it from login route param
     */
    uploadModulePost(params: {  module: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "module" is set
        if (params["module"] == null) {
            throw new Error("Missing required parameter module when calling uploadModulePost");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/{module}`
            .replace(`{${"module"}}`, `${ params["module"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ControllersApi - functional programming interface
 */
export const ControllersApiFp = {
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBrowserResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetBrowserGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCatResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetCategoryGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetIspGet
     * @param token the security token, get it from login route (def)
     */
    assetIspGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersIspResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetIspGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersManufacturers> {
        const fetchArgs = ControllersApiFetchParamCreator.assetManufacturersGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetOsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmWhiteBlackList> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryPresetPost(params: { token?: string; payloadData?: ControllersWhiteBlackList;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmWhiteBlackList> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetsGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersWhiteBlackLists> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModulePost(params: { module: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadModulePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * ControllersApi - object-oriented interface
 */
export class ControllersApi extends BaseAPI {
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetBrowserGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetCategoryGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetIspGet
     * @param token the security token, get it from login route (def)
     */
    assetIspGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetIspGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetManufacturersGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetsGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModulePost(params: {  module: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadModulePost(params, options)(this.fetch, this.basePath);
    }
}

/**
 * ControllersApi - factory interface
 */
export const ControllersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * assetBrowserGet
         * @param token the security token, get it from login route (def)
         */
        assetBrowserGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetBrowserGet(params, options)(fetch, basePath);
        },
        /**
         * assetCategoryGet
         * @param token the security token, get it from login route (def)
         */
        assetCategoryGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetCategoryGet(params, options)(fetch, basePath);
        },
        /**
         * assetIspGet
         * @param token the security token, get it from login route (def)
         */
        assetIspGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetIspGet(params, options)(fetch, basePath);
        },
        /**
         * assetManufacturersGet
         * @param token the security token, get it from login route (def)
         */
        assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetManufacturersGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsGet
         * @param token the security token, get it from login route (def)
         */
        assetOsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetIdGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetPost(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetsGet
         * @param token the security token, get it from login route (def)
         */
        inventoryPresetsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetsGet(params, options)(fetch, basePath);
        },
        /**
         * uploadModulePost
         * @param module  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadModulePost(params: {  module: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadModulePost(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationApi - fetch parameter creator
 */
export const LocationApiFetchParamCreator = {
    /**
     * @func
     * locationCitiesProvincesIdGet
     * @param provincesId  param
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "provincesId" is set
        if (params["provincesId"] == null) {
            throw new Error("Missing required parameter provincesId when calling locationCitiesProvincesIdGet");
        }
        const baseUrl = `/location/cities/{provinces_id}`
            .replace(`{${"provinces_id"}}`, `${ params["provincesId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationProvincesCountryIdGet
     * @param countryId  param
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryId" is set
        if (params["countryId"] == null) {
            throw new Error("Missing required parameter countryId when calling locationProvincesCountryIdGet");
        }
        const baseUrl = `/location/provinces/{country_id}`
            .replace(`{${"country_id"}}`, `${ params["countryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: { provincesId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCities> {
        const fetchArgs = LocationApiFetchParamCreator.locationCitiesProvincesIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCountries> {
        const fetchArgs = LocationApiFetchParamCreator.locationCountriesGet(options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: { countryId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationProvinces> {
        const fetchArgs = LocationApiFetchParamCreator.locationProvincesCountryIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
        return LocationApiFp.locationCitiesProvincesIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}) {
        return LocationApiFp.locationCountriesGet(options)(this.fetch, this.basePath);
    }
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
        return LocationApiFp.locationProvincesCountryIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * locationCitiesProvincesIdGet
         * @param provincesId  (def)
         */
        locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
            return LocationApiFp.locationCitiesProvincesIdGet(params, options)(fetch, basePath);
        },
        /**
         * locationCountriesGet
         */
        locationCountriesGet(options: any = {}) {
            return LocationApiFp.locationCountriesGet(options)(fetch, basePath);
        },
        /**
         * locationProvincesCountryIdGet
         * @param countryId  (def)
         */
        locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
            return LocationApiFp.locationProvincesCountryIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * @func
     * userActivePatch
     * @param payloadData  param
     */
    userActivePatch(params: {  payloadData?: UserCheckActivePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/active`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userActivePost
     * @param payloadData  param
     */
    userActivePost(params: {  payloadData?: UserSendActivePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/active`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLoginPost
     * @param payloadData  param
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route param
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout/closeother`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutGet
     * @param token the security token, get it from login route param
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userMailCheckPost
     * @param payloadData  param
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/mail/check`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordCallbackPut
     * @param payloadData  param
     */
    userPasswordCallbackPut(params: {  payloadData?: UserCallBack; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/callback`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordForgetPost
     * @param payloadData  param
     */
    userPasswordForgetPost(params: {  payloadData?: UserForget; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/forget`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPersonalPut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userPersonalPut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/personal`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPingGet
     * @param token the security token, get it from login route param
     */
    userPingGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/ping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userRegisterPost
     * @param payloadData  param
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * userActivePatch
     * @param payloadData  (def)
     */
    userActivePatch(params: { payloadData?: UserCheckActivePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userActivePatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userActivePost
     * @param payloadData  (def)
     */
    userActivePost(params: { payloadData?: UserSendActivePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userActivePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: { payloadData?: UserLoginPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLoginPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutCloseotherGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserCheckMailResponse> {
        const fetchArgs = UserApiFetchParamCreator.userMailCheckPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordCallbackPut
     * @param payloadData  (def)
     */
    userPasswordCallbackPut(params: { payloadData?: UserCallBack;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordCallbackPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: { payloadData?: UserForget;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordForgetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPersonalPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPersonalPut(params: { token?: string; payloadData?: UserUserPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPersonalPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPingGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userRegisterPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                  return response.json()
                  .then(res => {
                    throw res;
                  })
                  .catch((err) => {
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * userActivePatch
     * @param payloadData  (def)
     */
    userActivePatch(params: {  payloadData?: UserCheckActivePayload; }, options: any = {}) {
        return UserApiFp.userActivePatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * userActivePost
     * @param payloadData  (def)
     */
    userActivePost(params: {  payloadData?: UserSendActivePayload; }, options: any = {}) {
        return UserApiFp.userActivePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
        return UserApiFp.userLoginPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutCloseotherGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
        return UserApiFp.userMailCheckPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordCallbackPut
     * @param payloadData  (def)
     */
    userPasswordCallbackPut(params: {  payloadData?: UserCallBack; }, options: any = {}) {
        return UserApiFp.userPasswordCallbackPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
        return UserApiFp.userPasswordChangePut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: {  payloadData?: UserForget; }, options: any = {}) {
        return UserApiFp.userPasswordForgetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPersonalPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPersonalPut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
        return UserApiFp.userPersonalPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPingGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
        return UserApiFp.userRegisterPost(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * userActivePatch
         * @param payloadData  (def)
         */
        userActivePatch(params: {  payloadData?: UserCheckActivePayload; }, options: any = {}) {
            return UserApiFp.userActivePatch(params, options)(fetch, basePath);
        },
        /**
         * userActivePost
         * @param payloadData  (def)
         */
        userActivePost(params: {  payloadData?: UserSendActivePayload; }, options: any = {}) {
            return UserApiFp.userActivePost(params, options)(fetch, basePath);
        },
        /**
         * userLoginPost
         * @param payloadData  (def)
         */
        userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
            return UserApiFp.userLoginPost(params, options)(fetch, basePath);
        },
        /**
         * userLogoutCloseotherGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutCloseotherGet(params, options)(fetch, basePath);
        },
        /**
         * userLogoutGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutGet(params, options)(fetch, basePath);
        },
        /**
         * userMailCheckPost
         * @param payloadData  (def)
         */
        userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
            return UserApiFp.userMailCheckPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordCallbackPut
         * @param payloadData  (def)
         */
        userPasswordCallbackPut(params: {  payloadData?: UserCallBack; }, options: any = {}) {
            return UserApiFp.userPasswordCallbackPut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
            return UserApiFp.userPasswordChangePut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordForgetPost
         * @param payloadData  (def)
         */
        userPasswordForgetPost(params: {  payloadData?: UserForget; }, options: any = {}) {
            return UserApiFp.userPasswordForgetPost(params, options)(fetch, basePath);
        },
        /**
         * userPersonalPut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userPersonalPut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
            return UserApiFp.userPersonalPut(params, options)(fetch, basePath);
        },
        /**
         * userPingGet
         * @param token the security token, get it from login route (def)
         */
        userPingGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPingGet(params, options)(fetch, basePath);
        },
        /**
         * userRegisterPost
         * @param payloadData  (def)
         */
        userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
            return UserApiFp.userRegisterPost(params, options)(fetch, basePath);
        },
    };
};

