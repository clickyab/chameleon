/**
 * The clickyab.com/crab API
 * The crab api, auto generated
 *
 * OpenAPI spec version: 17
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";
import * as assign from "core-js/library/fn/object/assign";
import "whatwg-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://staging.crab.clickyab.ae/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    configuration: object;

    constructor(fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH, configuration: object = {}) {
        this.basePath = basePath;
        this.fetch = fetchFn;
        this.configuration = configuration;
    }
}

export interface ControllerErrorResponseSimple {
    "error"?: ControllerErrorResponseSimpleError;
}

export interface ControllerErrorResponseSimpleError {
    "params"?: Array<string>;
    "text"?: string;
}

export interface DmnActiveStatus {
}

export interface DmnDomain {
    "active"?: string;
    "createdAt"?: string;
    "description"?: DmnDomainDescription;
    "id"?: number;
    "name"?: string;
    "updatedAt"?: string;
}

export interface DmnDomainDescription {
    "string"?: string;
    "valid"?: boolean;
}

export interface TransT9Base {
    "params"?: Array<string>;
    "text"?: string;
}

export interface UserCheckMailPayload {
    "email"?: string;
}

export interface UserCheckMailResponse {
    "currentDomain"?: boolean;
    "domains"?: Array<UserCheckMailResponseDomains>;
}

export interface UserCheckMailResponseDomains {
    "active"?: string;
    "createdAt"?: string;
    "description"?: DmnDomainDescription;
    "id"?: number;
    "name"?: string;
    "updatedAt"?: string;
}

export interface UserRegisterPayload {
    "email"?: string;
    "password"?: string;
    "userType"?: string;
}

export interface UserResponseRegister {
    "email"?: string;
    "id"?: number;
    "token"?: string;
    "userType"?: string;
}



/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * @func
     * userMailCheckPost
     * @param payloadData  param
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/mail/check`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userRegisterPost
     * @param payloadData  param
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserCheckMailResponse> {
        const fetchArgs = UserApiFetchParamCreator.userMailCheckPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseRegister> {
        const fetchArgs = UserApiFetchParamCreator.userRegisterPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
        return UserApiFp.userMailCheckPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
        return UserApiFp.userRegisterPost(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * userMailCheckPost
         * @param payloadData  (def)
         */
        userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
            return UserApiFp.userMailCheckPost(params, options)(fetch, basePath);
        },
        /**
         * userRegisterPost
         * @param payloadData  (def)
         */
        userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
            return UserApiFp.userRegisterPost(params, options)(fetch, basePath);
        },
    };
};

