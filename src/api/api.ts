/**
 * The clickyab.com/crab API
 * The crab api, auto generated
 *
 * OpenAPI spec version: \"0.0.1-pre-alpha\"
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import AAA from "./../services/AAA/index";
import * as querystring from "querystring";
import * as url from "url";
import * as assign from "core-js/library/fn/object/assign";
import "whatwg-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

export const BASE_PATH = "http://staging.crab.clickyab.ae/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    configuration: object;

    constructor(fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH, configuration: object = {}) {
        this.basePath = basePath;
        this.fetch = fetchFn;
        this.configuration = configuration;
    }
}

export interface ControllerErrorResponseSimple {
    "error"?: ForbiddenError;
}

export interface ControllerNormalResponse {
}

export interface ControllersAttributesPayload {
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "device"?: Array<string>;
    "iab"?: Array<string>;
    "isp"?: Array<string>;
    "manufacturer"?: Array<string>;
    "os"?: Array<string>;
    "region"?: Array<string>;
}

export interface ControllersBrowserResponse extends Array<ControllersBrowserResponseInner> {
}

export interface ControllersBrowserResponseInner {
    "created_at"?: string;
    "deleted_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersBudgetPayload {
    "daily_budget"?: number;
    "exchange"?: string;
    "max_bid"?: number;
    "notify_users"?: Array<number>;
    "strategy"?: string;
    "total_budget"?: number;
}

export interface ControllersCampaignStatus {
    "end_at"?: string;
    "schedule"?: ControllersCampaignStatusSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface ControllersCampaignStatusSchedule {
    "h00"?: string;
    "h01"?: string;
    "h02"?: string;
    "h03"?: string;
    "h04"?: string;
    "h05"?: string;
    "h06"?: string;
    "h07"?: string;
    "h08"?: string;
    "h09"?: string;
    "h10"?: string;
    "h11"?: string;
    "h12"?: string;
    "h13"?: string;
    "h14"?: string;
    "h15"?: string;
    "h16"?: string;
    "h17"?: string;
    "h18"?: string;
    "h19"?: string;
    "h20"?: string;
    "h21"?: string;
    "h22"?: string;
    "h23"?: string;
}

export interface ControllersCatResponse extends Array<ControllersCatResponseInner> {
}

export interface ControllersCatResponseInner {
    "deleted_at"?: ControllersCatResponseInnerDeletedAt;
    "description"?: string;
    "name"?: string;
}

export interface ControllersCatResponseInnerDeletedAt {
    "Time"?: string;
    "Valid"?: boolean;
}

export interface ControllersCopyCampaignPayload {
    "title"?: string;
}

export interface ControllersCreateCampaignPayload {
    "end_at"?: string;
    "kind"?: string;
    "schedule"?: ControllersCampaignStatusSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface ControllersGetNativeDataPayload {
    "url"?: string;
}

export interface ControllersGetNativeDataResp {
    "description"?: string;
    "image"?: string;
    "site_name"?: string;
    "title"?: string;
    "url"?: string;
}

export interface ControllersGetVideoResponse {
    "ready"?: string;
}

export interface ControllersGraphChartData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartResponse {
    "data"?: Array<ControllersGraphChartResponseData>;
    "format"?: string;
    "from"?: string;
    "to"?: string;
    "type"?: string;
}

export interface ControllersGraphChartResponseData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersIspResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersIspResponseInner {
    "created_at"?: string;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersListCampaignDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListCampaignDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
}

export interface ControllersListCampaignDefResponseColumns {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface ControllersListCampaignResponse {
    "data"?: Array<ControllersListCampaignResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCampaignResponseData {
    "_actions"?: string;
    "active"?: boolean;
    "avg_cpc"?: number;
    "avg_cpm"?: number;
    "budget"?: number;
    "cost_type"?: string;
    "created_at"?: string;
    "ctr"?: number;
    "daily_limit"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "id"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "owner_id"?: number;
    "parent_email"?: ControllersListCampaignResponseParentEmail;
    "start_at"?: string;
    "status"?: boolean;
    "title"?: string;
    "today_click"?: number;
    "today_ctr"?: number;
    "today_imp"?: number;
    "total_click"?: number;
    "total_conv"?: number;
    "total_cpc"?: number;
    "total_cpm"?: number;
    "total_imp"?: number;
    "total_spent"?: number;
}

export interface ControllersListCampaignResponseParentEmail {
    "String"?: string;
    "Valid"?: boolean;
}

export interface ControllersListCampaigndailyDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListCampaignDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
}

export interface ControllersListCampaigndailyResponse {
    "data"?: Array<ControllersListCampaigndailyResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCampaigndailyResponseData {
    "_actions"?: string;
    "click"?: number;
    "conv"?: number;
    "cpa"?: number;
    "cpc"?: number;
    "cpm"?: number;
    "created_at"?: string;
    "ctr"?: number;
    "imp"?: number;
    "spent"?: number;
}

export interface ControllersListInventoryDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListCampaignDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
}

export interface ControllersListInventoryResponse {
    "data"?: Array<ControllersListInventoryResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListInventoryResponseData {
    "_actions"?: string;
    "active"?: boolean;
    "cat"?: Array<string>;
    "created_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "publisher"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersManufacturers extends Array<ControllersManufacturersInner> {
}

export interface ControllersManufacturersInner {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersNativeCreativePayload {
    "assets"?: ControllersNativeCreativePayloadAssets;
    "creative"?: ControllersNativeCreativePayloadCreative;
}

export interface ControllersNativeCreativePayloadAssets {
    "cta"?: string;
    "description"?: string;
    "downloads"?: number;
    "icon"?: string;
    "image"?: string;
    "logo"?: string;
    "phone"?: string;
    "price"?: number;
    "rating"?: number;
    "saleprice"?: number;
    "title"?: string;
    "video"?: string;
}

export interface ControllersNativeCreativePayloadCreative {
    "attributes"?: string;
    "campaign_id"?: number;
    "max_bid"?: number;
    "status"?: string;
    "url"?: string;
}

export interface ControllersOsResponse extends Array<ControllersManufacturersInner> {
}

export interface ControllersPlatformResponse extends Array<ControllersManufacturersInner> {
}

export interface ControllersSliceAds extends Array<ControllersSliceAdsInner> {
}

export interface ControllersSliceAdsInner {
    "archived_at"?: string;
    "attributes"?: string;
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
    "user_id"?: number;
}

export interface ControllersUploadResponse {
    "src"?: string;
}

export interface ControllersWhiteBlackList {
    "domains"?: Array<string>;
    "label"?: string;
    "publisher_type"?: string;
}

export interface ControllersWhiteBlackLists extends Array<ControllersWhiteBlackListsInner> {
}

export interface ControllersWhiteBlackListsInner {
    "active"?: boolean;
    "created_at"?: string;
    "domain_id"?: number;
    "domains"?: { [key: string]: Array<string>; };
    "id"?: number;
    "label"?: string;
    "publisher_type"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersWhiteBlackPayload {
    "exchange"?: string;
    "list_id"?: number;
    "white_typ"?: boolean;
}

export interface Forbidden {
    "error"?: ForbiddenError;
}

export interface ForbiddenError {
    "params"?: Array<string>;
    "text"?: string;
}

export interface LocationCities extends Array<LocationCitiesInner> {
}

export interface LocationCitiesInner {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCity {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCountries extends Array<LocationCountriesInner> {
}

export interface LocationCountriesInner {
    "id"?: number;
    "name"?: string;
}

export interface LocationCountry {
    "id"?: number;
    "name"?: string;
}

export interface LocationProvince {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface LocationProvinces extends Array<LocationProvincesInner> {
}

export interface LocationProvincesInner {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface OrmAdUser {
    "archived_at"?: string;
    "attributes"?: string;
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
    "user_id"?: number;
}

export interface OrmAsset {
    "asset_key"?: string;
    "asset_type"?: string;
    "asset_value"?: string;
    "created_at"?: string;
    "creative_id"?: number;
    "id"?: number;
    "property"?: string;
    "updated_at"?: string;
}

export interface OrmAssetStatus {
}

export interface OrmAssetTypes {
}

export interface OrmBase {
    "created_at"?: string;
    "id"?: number;
    "updated_at"?: string;
}

export interface OrmBrowser {
    "created_at"?: string;
    "deleted_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmCampaign {
    "archived_at"?: string;
    "attributes"?: OrmCampaignAttributes;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: OrmCampaignInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "receivers"?: Array<OrmCampaignReceivers>;
    "schedule"?: OrmCampaignSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmCampaignAttributes {
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "device"?: Array<string>;
    "iab"?: Array<string>;
    "isp"?: Array<string>;
    "manufacturer"?: Array<string>;
    "os"?: Array<string>;
    "region"?: Array<string>;
}

export interface OrmCampaignBaseType {
    "kind"?: string;
}

export interface OrmCampaignDailyDataTable {
    "_actions"?: string;
    "click"?: number;
    "conv"?: number;
    "cpa"?: number;
    "cpc"?: number;
    "cpm"?: number;
    "created_at"?: string;
    "ctr"?: number;
    "imp"?: number;
    "spent"?: number;
}

export interface OrmCampaignDataTable {
    "_actions"?: string;
    "active"?: boolean;
    "avg_cpc"?: number;
    "avg_cpm"?: number;
    "budget"?: number;
    "cost_type"?: string;
    "created_at"?: string;
    "ctr"?: number;
    "daily_limit"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "id"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "owner_id"?: number;
    "parent_email"?: ControllersListCampaignResponseParentEmail;
    "start_at"?: string;
    "status"?: boolean;
    "title"?: string;
    "today_click"?: number;
    "today_ctr"?: number;
    "today_imp"?: number;
    "total_click"?: number;
    "total_conv"?: number;
    "total_cpc"?: number;
    "total_cpm"?: number;
    "total_imp"?: number;
    "total_spent"?: number;
}

export interface OrmCampaignFinance {
    "daily_budget"?: number;
    "max_bid"?: number;
    "strategy"?: string;
    "total_budget"?: number;
}

export interface OrmCampaignInventoryType {
    "InventoryState"?: string;
    "Valid"?: boolean;
}

export interface OrmCampaignKind {
}

export interface OrmCampaignReceivers {
    "email"?: string;
    "id"?: number;
}

export interface OrmCampaignSchedule {
    "h00"?: ControllersListCampaignResponseParentEmail;
    "h01"?: ControllersListCampaignResponseParentEmail;
    "h02"?: ControllersListCampaignResponseParentEmail;
    "h03"?: ControllersListCampaignResponseParentEmail;
    "h04"?: ControllersListCampaignResponseParentEmail;
    "h05"?: ControllersListCampaignResponseParentEmail;
    "h06"?: ControllersListCampaignResponseParentEmail;
    "h07"?: ControllersListCampaignResponseParentEmail;
    "h08"?: ControllersListCampaignResponseParentEmail;
    "h09"?: ControllersListCampaignResponseParentEmail;
    "h10"?: ControllersListCampaignResponseParentEmail;
    "h11"?: ControllersListCampaignResponseParentEmail;
    "h12"?: ControllersListCampaignResponseParentEmail;
    "h13"?: ControllersListCampaignResponseParentEmail;
    "h14"?: ControllersListCampaignResponseParentEmail;
    "h15"?: ControllersListCampaignResponseParentEmail;
    "h16"?: ControllersListCampaignResponseParentEmail;
    "h17"?: ControllersListCampaignResponseParentEmail;
    "h18"?: ControllersListCampaignResponseParentEmail;
    "h19"?: ControllersListCampaignResponseParentEmail;
    "h20"?: ControllersListCampaignResponseParentEmail;
    "h21"?: ControllersListCampaignResponseParentEmail;
    "h22"?: ControllersListCampaignResponseParentEmail;
    "h23"?: ControllersListCampaignResponseParentEmail;
}

export interface OrmCampaignStatus {
    "end_at"?: string;
    "schedule"?: OrmCampaignSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface OrmCategory {
    "deleted_at"?: ControllersCatResponseInnerDeletedAt;
    "description"?: string;
    "name"?: string;
}

export interface OrmCreative {
    "archived_at"?: string;
    "attributes"?: string;
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
}

export interface OrmCreativeSaveResult {
    "assets"?: Array<OrmCreativeSaveResultAssets>;
    "creative"?: OrmCreativeSaveResultCreative;
}

export interface OrmCreativeSaveResultAssets {
    "asset_key"?: string;
    "asset_type"?: string;
    "asset_value"?: string;
    "created_at"?: string;
    "creative_id"?: number;
    "id"?: number;
    "property"?: string;
    "updated_at"?: string;
}

export interface OrmCreativeSaveResultCreative {
    "archived_at"?: string;
    "attributes"?: string;
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
}

export interface OrmCreativeStatusType {
}

export interface OrmCreativeTypes {
}

export interface OrmDomain {
    "attributes"?: { [key: string]: string; };
    "created_at"?: string;
    "description"?: ControllersListCampaignResponseParentEmail;
    "id"?: number;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmDomainStatus {
}

export interface OrmExchangeType {
}

export interface OrmISP {
    "created_at"?: string;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmISPKind {
}

export interface OrmInventory {
    "active"?: boolean;
    "cat"?: Array<string>;
    "created_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "publisher"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmInventoryDataTable {
    "_actions"?: string;
    "active"?: boolean;
    "cat"?: Array<string>;
    "created_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "publisher"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmInventoryState {
}

export interface OrmManufacturer {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmNullInventoryState {
    "InventoryState"?: string;
    "Valid"?: boolean;
}

export interface OrmOS {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmPlatform {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmProgress {
}

export interface OrmPublisherType {
}

export interface OrmReceiver {
    "email"?: string;
    "id"?: number;
}

export interface OrmScheduleSheet {
    "h00"?: ControllersListCampaignResponseParentEmail;
    "h01"?: ControllersListCampaignResponseParentEmail;
    "h02"?: ControllersListCampaignResponseParentEmail;
    "h03"?: ControllersListCampaignResponseParentEmail;
    "h04"?: ControllersListCampaignResponseParentEmail;
    "h05"?: ControllersListCampaignResponseParentEmail;
    "h06"?: ControllersListCampaignResponseParentEmail;
    "h07"?: ControllersListCampaignResponseParentEmail;
    "h08"?: ControllersListCampaignResponseParentEmail;
    "h09"?: ControllersListCampaignResponseParentEmail;
    "h10"?: ControllersListCampaignResponseParentEmail;
    "h11"?: ControllersListCampaignResponseParentEmail;
    "h12"?: ControllersListCampaignResponseParentEmail;
    "h13"?: ControllersListCampaignResponseParentEmail;
    "h14"?: ControllersListCampaignResponseParentEmail;
    "h15"?: ControllersListCampaignResponseParentEmail;
    "h16"?: ControllersListCampaignResponseParentEmail;
    "h17"?: ControllersListCampaignResponseParentEmail;
    "h18"?: ControllersListCampaignResponseParentEmail;
    "h19"?: ControllersListCampaignResponseParentEmail;
    "h20"?: ControllersListCampaignResponseParentEmail;
    "h21"?: ControllersListCampaignResponseParentEmail;
    "h22"?: ControllersListCampaignResponseParentEmail;
    "h23"?: ControllersListCampaignResponseParentEmail;
}

export interface OrmStatus {
}

export interface OrmStrategy {
}

export interface OrmWhiteBlackList {
    "active"?: boolean;
    "created_at"?: string;
    "domain_id"?: number;
    "domains"?: { [key: string]: Array<string>; };
    "id"?: number;
    "label"?: string;
    "publisher_type"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface PermissionColumn {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface TransT9Base {
    "params"?: Array<string>;
    "text"?: string;
}

export interface UserAvatarPayload {
    "avatar"?: string;
}

export interface UserCallBackPayload {
    "new_password"?: string;
}

export interface UserChangePassword {
    "current_password"?: string;
    "new_password"?: string;
}

export interface UserCheckMailPayload {
    "email"?: string;
}

export interface UserCheckMailResponse {
    "current_domain"?: boolean;
    "domains"?: Array<UserCheckMailResponseDomains>;
}

export interface UserCheckMailResponseDomains {
    "attributes"?: { [key: string]: string; };
    "created_at"?: string;
    "description"?: ControllersListCampaignResponseParentEmail;
    "id"?: number;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface UserForgetCodePayload {
    "code"?: string;
    "email"?: string;
}

export interface UserForgetPayload {
    "email"?: string;
}

export interface UserLoginPayload {
    "email"?: string;
    "password"?: string;
}

export interface UserRegisterPayload {
    "email"?: string;
    "first_name"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "mobile"?: string;
    "password"?: string;
}

export interface UserResponseLoginOK {
    "account"?: UserResponseLoginOKAccount;
    "token"?: string;
}

export interface UserResponseLoginOKAccount {
    "address"?: string;
    "attributes"?: { [key: string]: string; };
    "avatar"?: string;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserStorePayload {
    "data"?: { [key: string]: string; };
}

export interface UserUserPayload {
    "address"?: string;
    "cell_phone"?: string;
    "city_id"?: number;
    "economic_code"?: string;
    "first_name"?: string;
    "gender"?: string;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "ssn"?: string;
}

export interface UserUserResponse {
    "address"?: string;
    "attributes"?: { [key: string]: string; };
    "avatar"?: string;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserVerifyEmailCodePayload {
    "code"?: string;
    "email"?: string;
}

export interface UserVerifyResendPayload {
    "email"?: string;
}



/**
 * ControllersApi - fetch parameter creator
 */
export const ControllersApiFetchParamCreator = {
    /**
     * @func
     * adNativeCreativeIdPut
     * @param creativeId  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adNativeCreativeIdPut(params: {  creativeId: string; token?: string; payloadData?: ControllersNativeCreativePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "creativeId" is set
        if (params["creativeId"] == null) {
            throw new Error("Missing required parameter creativeId when calling adNativeCreativeIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/native/{creative_id}`
            .replace(`{${"creative_id"}}`, `${ params["creativeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adNativePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adNativePost(params: {  token?: string; payloadData?: ControllersNativeCreativePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/native`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetBrowserGet
     * @param token the security token, get it from login route param
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/browser`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetCategoryGet
     * @param token the security token, get it from login route param
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/category`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetIspKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetIspKindGet(params: {  kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetIspKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/isp/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetManufacturersGet
     * @param token the security token, get it from login route param
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/manufacturers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsGet
     * @param token the security token, get it from login route param
     */
    assetOsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetOsKindGet(params: {  kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetOsKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetPlatformGet
     * @param token the security token, get it from login route param
     */
    assetPlatformGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/platform`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetPlatformKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetPlatformKindGet(params: {  kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetPlatformKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/platform/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignAttributesIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignAttributesIdPut(params: {  id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignAttributesIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/attributes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignBaseIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignBaseIdPut(params: {  id: string; token?: string; payloadData?: ControllersCampaignStatus; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignBaseIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/base/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignBudgetIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignBudgetIdPut(params: {  id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignBudgetIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/budget/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCreatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignCreatePost(params: {  token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignDailyIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignDailyIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignDailyIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/daily/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignDailyIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param p  page number param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    campaignDailyIdGet(params: {  id: string; token?: string; c?: string; p?: string; from?: string; sort?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignDailyIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/daily/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignFinalizeIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignFinalizeIdPut(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignFinalizeIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/finalize/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGetIdAdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignGetIdAdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGetIdAdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/get/{id}/ad`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGetIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignGetIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGetIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/get/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGraphAllGet
     * @param token the security token, get it from login route param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param ownerEmail  search the owner_email field param
     * @param title  search the title field param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param kind  param
     */
    campaignGraphAllGet(params: {  token?: string; to?: string; ownerEmail?: string; title?: string; from?: string; kind?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/graph/all`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["ownerEmail"] !== undefined) {
            urlObj.query["owner_email"] = params["ownerEmail"];
        }
        if (params["title"] !== undefined) {
            urlObj.query["title"] = params["title"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignIdPatch(params: {  id: string; token?: string; payloadData?: ControllersCopyCampaignPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignIdStatPatch
     * @param id  param
     * @param stat  param
     * @param token the security token, get it from login route param
     */
    campaignIdStatPatch(params: {  id: string; stat: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignIdStatPatch");
        }
        // verify required parameter "stat" is set
        if (params["stat"] == null) {
            throw new Error("Missing required parameter stat when calling campaignIdStatPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/{id}/{stat}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"stat"}}`, `${ params["stat"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignListDefinitionGet
     * @param token the security token, get it from login route param
     */
    campaignListDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignListGet
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param p  page number param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param kind  param
     * @param costType  param
     * @param title  search the title field param
     * @param ownerEmail  search the owner_email field param
     */
    campaignListGet(params: {  token?: string; c?: string; p?: string; from?: string; to?: string; sort?: string; kind?: string; costType?: string; title?: string; ownerEmail?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["costType"] !== undefined) {
            urlObj.query["cost_type"] = params["costType"];
        }
        if (params["title"] !== undefined) {
            urlObj.query["title"] = params["title"];
        }
        if (params["ownerEmail"] !== undefined) {
            urlObj.query["owner_email"] = params["ownerEmail"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignNativeFetchPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignNativeFetchPost(params: {  token?: string; payloadData?: ControllersGetNativeDataPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/native/fetch`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignWbIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignWbIdPut(params: {  id: string; token?: string; payloadData?: ControllersWhiteBlackPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignWbIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/wb/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignWblistIdDelete
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignWblistIdDelete(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignWblistIdDelete");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/wblist/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryListDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryListDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryListGet
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param kind  param
     * @param name  search the name field param
     * @param sort  param
     * @param domain  search the domain field param
     * @param p  page number param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    inventoryListGet(params: {  token?: string; c?: string; kind?: string; name?: string; sort?: string; domain?: string; p?: string; from?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPresetIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/preset/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/preset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPresetsGet
     * @param token the security token, get it from login route param
     */
    inventoryPresetsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/presets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadModuleModulePost
     * @param module  param
     * @param token the security token, get it from login route param
     */
    uploadModuleModulePost(params: {  module: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "module" is set
        if (params["module"] == null) {
            throw new Error("Missing required parameter module when calling uploadModuleModulePost");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/module/{module}`
            .replace(`{${"module"}}`, `${ params["module"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadVideoIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    uploadVideoIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling uploadVideoIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/video/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadVideoPost
     * @param token the security token, get it from login route param
     */
    uploadVideoPost(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/video`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ControllersApi - functional programming interface
 */
export const ControllersApiFp = {
    /**
     * adNativeCreativeIdPut
     * @param creativeId  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativeCreativeIdPut(params: { creativeId: string; token?: string; payloadData?: ControllersNativeCreativePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        const fetchArgs = ControllersApiFetchParamCreator.adNativeCreativeIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * adNativePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativePost(params: { token?: string; payloadData?: ControllersNativeCreativePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        const fetchArgs = ControllersApiFetchParamCreator.adNativePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBrowserResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetBrowserGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCatResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetCategoryGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetIspKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetIspKindGet(params: { kind: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersIspResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetIspKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersManufacturers> {
        const fetchArgs = ControllersApiFetchParamCreator.assetManufacturersGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetOsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetOsKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetOsKindGet(params: { kind: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetOsKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetPlatformGet
     * @param token the security token, get it from login route (def)
     */
    assetPlatformGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersPlatformResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetPlatformGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetPlatformKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetPlatformKindGet(params: { kind: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersPlatformResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetPlatformKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignAttributesIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignAttributesIdPut(params: { id: string; token?: string; payloadData?: ControllersAttributesPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignAttributesIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignBaseIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBaseIdPut(params: { id: string; token?: string; payloadData?: ControllersCampaignStatus;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignBaseIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignBudgetIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBudgetIdPut(params: { id: string; token?: string; payloadData?: ControllersBudgetPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignBudgetIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCreatePost(params: { token?: string; payloadData?: ControllersCreateCampaignPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignCreatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignDailyIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignDailyIdDefinitionGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaigndailyDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignDailyIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignDailyIdGet(params: { id: string; token?: string; c?: string; p?: string; from?: string; sort?: string; to?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaigndailyResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignDailyIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignFinalizeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignFinalizeIdPut(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignFinalizeIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignGetIdAdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdAdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersSliceAds> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignGetIdAdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignGetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignGetIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignGraphAllGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param title  search the title field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     */
    campaignGraphAllGet(params: { token?: string; to?: string; ownerEmail?: string; title?: string; from?: string; kind?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGraphChartResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignGraphAllGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignIdPatch(params: { id: string; token?: string; payloadData?: ControllersCopyCampaignPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignIdStatPatch
     * @param id  (def)
     * @param stat  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignIdStatPatch(params: { id: string; stat: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignIdStatPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    campaignListDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaignDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignListGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param kind  (def)
     * @param costType  (def)
     * @param title  search the title field (def)
     * @param ownerEmail  search the owner_email field (def)
     */
    campaignListGet(params: { token?: string; c?: string; p?: string; from?: string; to?: string; sort?: string; kind?: string; costType?: string; title?: string; ownerEmail?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaignResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignNativeFetchPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignNativeFetchPost(params: { token?: string; payloadData?: ControllersGetNativeDataPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetNativeDataResp> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignNativeFetchPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignWbIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignWbIdPut(params: { id: string; token?: string; payloadData?: ControllersWhiteBlackPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignWbIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignWblistIdDelete
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignWblistIdDelete(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignWblistIdDelete(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryListDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInventoryDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryListGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param kind  (def)
     * @param name  search the name field (def)
     * @param sort  (def)
     * @param domain  search the domain field (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    inventoryListGet(params: { token?: string; c?: string; kind?: string; name?: string; sort?: string; domain?: string; p?: string; from?: string; to?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInventoryResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmWhiteBlackList> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryPresetPost(params: { token?: string; payloadData?: ControllersWhiteBlackList;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmWhiteBlackList> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPresetsGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersWhiteBlackLists> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPresetsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadModuleModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModuleModulePost(params: { module: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersUploadResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadModuleModulePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadVideoIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadVideoIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetVideoResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadVideoIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadVideoPost
     * @param token the security token, get it from login route (def)
     */
    uploadVideoPost(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersUploadResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadVideoPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * ControllersApi - object-oriented interface
 */
export class ControllersApi extends BaseAPI {
    /**
     * adNativeCreativeIdPut
     * @param creativeId  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativeCreativeIdPut(params: {  creativeId: string; token?: string; payloadData?: ControllersNativeCreativePayload; }, options: any = {}) {
        return ControllersApiFp.adNativeCreativeIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * adNativePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativePost(params: {  token?: string; payloadData?: ControllersNativeCreativePayload; }, options: any = {}) {
        return ControllersApiFp.adNativePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetBrowserGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetCategoryGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetIspKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetIspKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetIspKindGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetManufacturersGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetOsKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetOsKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsKindGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetPlatformGet
     * @param token the security token, get it from login route (def)
     */
    assetPlatformGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetPlatformGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetPlatformKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetPlatformKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetPlatformKindGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignAttributesIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignAttributesIdPut(params: {  id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}) {
        return ControllersApiFp.campaignAttributesIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignBaseIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBaseIdPut(params: {  id: string; token?: string; payloadData?: ControllersCampaignStatus; }, options: any = {}) {
        return ControllersApiFp.campaignBaseIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignBudgetIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBudgetIdPut(params: {  id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}) {
        return ControllersApiFp.campaignBudgetIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCreatePost(params: {  token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}) {
        return ControllersApiFp.campaignCreatePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignDailyIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignDailyIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignDailyIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignDailyIdGet(params: {  id: string; token?: string; c?: string; p?: string; from?: string; sort?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.campaignDailyIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignFinalizeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignFinalizeIdPut(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignFinalizeIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignGetIdAdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdAdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGetIdAdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignGetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGetIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignGraphAllGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param title  search the title field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     */
    campaignGraphAllGet(params: {  token?: string; to?: string; ownerEmail?: string; title?: string; from?: string; kind?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGraphAllGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignIdPatch(params: {  id: string; token?: string; payloadData?: ControllersCopyCampaignPayload; }, options: any = {}) {
        return ControllersApiFp.campaignIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignIdStatPatch
     * @param id  (def)
     * @param stat  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignIdStatPatch(params: {  id: string; stat: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignIdStatPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    campaignListDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignListDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignListGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param kind  (def)
     * @param costType  (def)
     * @param title  search the title field (def)
     * @param ownerEmail  search the owner_email field (def)
     */
    campaignListGet(params: {  token?: string; c?: string; p?: string; from?: string; to?: string; sort?: string; kind?: string; costType?: string; title?: string; ownerEmail?: string; }, options: any = {}) {
        return ControllersApiFp.campaignListGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignNativeFetchPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignNativeFetchPost(params: {  token?: string; payloadData?: ControllersGetNativeDataPayload; }, options: any = {}) {
        return ControllersApiFp.campaignNativeFetchPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignWbIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignWbIdPut(params: {  id: string; token?: string; payloadData?: ControllersWhiteBlackPayload; }, options: any = {}) {
        return ControllersApiFp.campaignWbIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignWblistIdDelete
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignWblistIdDelete(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignWblistIdDelete(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryListDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryListDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryListGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param kind  (def)
     * @param name  search the name field (def)
     * @param sort  (def)
     * @param domain  search the domain field (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    inventoryListGet(params: {  token?: string; c?: string; kind?: string; name?: string; sort?: string; domain?: string; p?: string; from?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryListGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPresetsGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPresetsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPresetsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadModuleModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModuleModulePost(params: {  module: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadModuleModulePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadVideoIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadVideoIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadVideoIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadVideoPost
     * @param token the security token, get it from login route (def)
     */
    uploadVideoPost(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadVideoPost(params, options)(this.fetch, this.basePath);
    }
}

/**
 * ControllersApi - factory interface
 */
export const ControllersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * adNativeCreativeIdPut
         * @param creativeId  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adNativeCreativeIdPut(params: {  creativeId: string; token?: string; payloadData?: ControllersNativeCreativePayload; }, options: any = {}) {
            return ControllersApiFp.adNativeCreativeIdPut(params, options)(fetch, basePath);
        },
        /**
         * adNativePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adNativePost(params: {  token?: string; payloadData?: ControllersNativeCreativePayload; }, options: any = {}) {
            return ControllersApiFp.adNativePost(params, options)(fetch, basePath);
        },
        /**
         * assetBrowserGet
         * @param token the security token, get it from login route (def)
         */
        assetBrowserGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetBrowserGet(params, options)(fetch, basePath);
        },
        /**
         * assetCategoryGet
         * @param token the security token, get it from login route (def)
         */
        assetCategoryGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetCategoryGet(params, options)(fetch, basePath);
        },
        /**
         * assetIspKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetIspKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetIspKindGet(params, options)(fetch, basePath);
        },
        /**
         * assetManufacturersGet
         * @param token the security token, get it from login route (def)
         */
        assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetManufacturersGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsGet
         * @param token the security token, get it from login route (def)
         */
        assetOsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetOsKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsKindGet(params, options)(fetch, basePath);
        },
        /**
         * assetPlatformGet
         * @param token the security token, get it from login route (def)
         */
        assetPlatformGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetPlatformGet(params, options)(fetch, basePath);
        },
        /**
         * assetPlatformKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetPlatformKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetPlatformKindGet(params, options)(fetch, basePath);
        },
        /**
         * campaignAttributesIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignAttributesIdPut(params: {  id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}) {
            return ControllersApiFp.campaignAttributesIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignBaseIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignBaseIdPut(params: {  id: string; token?: string; payloadData?: ControllersCampaignStatus; }, options: any = {}) {
            return ControllersApiFp.campaignBaseIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignBudgetIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignBudgetIdPut(params: {  id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}) {
            return ControllersApiFp.campaignBudgetIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignCreatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignCreatePost(params: {  token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}) {
            return ControllersApiFp.campaignCreatePost(params, options)(fetch, basePath);
        },
        /**
         * campaignDailyIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignDailyIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignDailyIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignDailyIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        campaignDailyIdGet(params: {  id: string; token?: string; c?: string; p?: string; from?: string; sort?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.campaignDailyIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignFinalizeIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignFinalizeIdPut(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignFinalizeIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignGetIdAdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignGetIdAdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGetIdAdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignGetIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignGetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGetIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignGraphAllGet
         * @param token the security token, get it from login route (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param ownerEmail  search the owner_email field (def)
         * @param title  search the title field (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param kind  (def)
         */
        campaignGraphAllGet(params: {  token?: string; to?: string; ownerEmail?: string; title?: string; from?: string; kind?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGraphAllGet(params, options)(fetch, basePath);
        },
        /**
         * campaignIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignIdPatch(params: {  id: string; token?: string; payloadData?: ControllersCopyCampaignPayload; }, options: any = {}) {
            return ControllersApiFp.campaignIdPatch(params, options)(fetch, basePath);
        },
        /**
         * campaignIdStatPatch
         * @param id  (def)
         * @param stat  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignIdStatPatch(params: {  id: string; stat: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignIdStatPatch(params, options)(fetch, basePath);
        },
        /**
         * campaignListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        campaignListDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignListGet
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param kind  (def)
         * @param costType  (def)
         * @param title  search the title field (def)
         * @param ownerEmail  search the owner_email field (def)
         */
        campaignListGet(params: {  token?: string; c?: string; p?: string; from?: string; to?: string; sort?: string; kind?: string; costType?: string; title?: string; ownerEmail?: string; }, options: any = {}) {
            return ControllersApiFp.campaignListGet(params, options)(fetch, basePath);
        },
        /**
         * campaignNativeFetchPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignNativeFetchPost(params: {  token?: string; payloadData?: ControllersGetNativeDataPayload; }, options: any = {}) {
            return ControllersApiFp.campaignNativeFetchPost(params, options)(fetch, basePath);
        },
        /**
         * campaignWbIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignWbIdPut(params: {  id: string; token?: string; payloadData?: ControllersWhiteBlackPayload; }, options: any = {}) {
            return ControllersApiFp.campaignWbIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignWblistIdDelete
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignWblistIdDelete(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignWblistIdDelete(params, options)(fetch, basePath);
        },
        /**
         * inventoryListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryListDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryListGet
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param kind  (def)
         * @param name  search the name field (def)
         * @param sort  (def)
         * @param domain  search the domain field (def)
         * @param p  page number (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        inventoryListGet(params: {  token?: string; c?: string; kind?: string; name?: string; sort?: string; domain?: string; p?: string; from?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryListGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        inventoryPresetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetIdGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryPresetPost(params: {  token?: string; payloadData?: ControllersWhiteBlackList; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetPost(params, options)(fetch, basePath);
        },
        /**
         * inventoryPresetsGet
         * @param token the security token, get it from login route (def)
         */
        inventoryPresetsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPresetsGet(params, options)(fetch, basePath);
        },
        /**
         * uploadModuleModulePost
         * @param module  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadModuleModulePost(params: {  module: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadModuleModulePost(params, options)(fetch, basePath);
        },
        /**
         * uploadVideoIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadVideoIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadVideoIdGet(params, options)(fetch, basePath);
        },
        /**
         * uploadVideoPost
         * @param token the security token, get it from login route (def)
         */
        uploadVideoPost(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadVideoPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationApi - fetch parameter creator
 */
export const LocationApiFetchParamCreator = {
    /**
     * @func
     * locationCitiesProvincesIdGet
     * @param provincesId  param
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "provincesId" is set
        if (params["provincesId"] == null) {
            throw new Error("Missing required parameter provincesId when calling locationCitiesProvincesIdGet");
        }
        const baseUrl = `/location/cities/{provinces_id}`
            .replace(`{${"provinces_id"}}`, `${ params["provincesId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationProvincesCountryIdGet
     * @param countryId  param
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryId" is set
        if (params["countryId"] == null) {
            throw new Error("Missing required parameter countryId when calling locationProvincesCountryIdGet");
        }
        const baseUrl = `/location/provinces/{country_id}`
            .replace(`{${"country_id"}}`, `${ params["countryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: { provincesId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCities> {
        const fetchArgs = LocationApiFetchParamCreator.locationCitiesProvincesIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCountries> {
        const fetchArgs = LocationApiFetchParamCreator.locationCountriesGet(options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: { countryId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationProvinces> {
        const fetchArgs = LocationApiFetchParamCreator.locationProvincesCountryIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
        return LocationApiFp.locationCitiesProvincesIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}) {
        return LocationApiFp.locationCountriesGet(options)(this.fetch, this.basePath);
    }
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
        return LocationApiFp.locationProvincesCountryIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * locationCitiesProvincesIdGet
         * @param provincesId  (def)
         */
        locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
            return LocationApiFp.locationCitiesProvincesIdGet(params, options)(fetch, basePath);
        },
        /**
         * locationCountriesGet
         */
        locationCountriesGet(options: any = {}) {
            return LocationApiFp.locationCountriesGet(options)(fetch, basePath);
        },
        /**
         * locationProvincesCountryIdGet
         * @param countryId  (def)
         */
        locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
            return LocationApiFp.locationProvincesCountryIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * @func
     * userAvatarPut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userAvatarPut(params: {  token?: string; payloadData?: UserAvatarPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/avatar`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyPost
     * @param payloadData  param
     */
    userEmailVerifyPost(params: {  payloadData?: UserVerifyEmailCodePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyResendPost
     * @param payloadData  param
     */
    userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify/resend`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyTokenGet
     * @param token  param
     */
    userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/email/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLoginPost
     * @param payloadData  param
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route param
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout/closeother`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutGet
     * @param token the security token, get it from login route param
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userMailCheckPost
     * @param payloadData  param
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/mail/check`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangeTokenPut
     * @param token  param
     * @param payloadData  param
     */
    userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordForgetPost
     * @param payloadData  param
     */
    userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/forget`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyPost
     * @param payloadData  param
     */
    userPasswordVerifyPost(params: {  payloadData?: UserForgetCodePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/verify/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyTokenGet
     * @param token  param
     */
    userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPingGet
     * @param token the security token, get it from login route param
     */
    userPingGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/ping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userRegisterPost
     * @param payloadData  param
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userStorePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userStorePost(params: {  token?: string; payloadData?: UserStorePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/store`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userUpdatePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/update`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * userAvatarPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAvatarPut(params: { token?: string; payloadData?: UserAvatarPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userAvatarPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyPost
     * @param payloadData  (def)
     */
    userEmailVerifyPost(params: { payloadData?: UserVerifyEmailCodePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyResendPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: { payloadData?: UserLoginPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLoginPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutCloseotherGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserCheckMailResponse> {
        const fetchArgs = UserApiFetchParamCreator.userMailCheckPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangeTokenPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: { payloadData?: UserForgetPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordForgetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordVerifyPost
     * @param payloadData  (def)
     */
    userPasswordVerifyPost(params: { payloadData?: UserForgetCodePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPingGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userRegisterPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userStorePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStorePost(params: { token?: string; payloadData?: UserStorePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userStorePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: { token?: string; payloadData?: UserUserPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userUpdatePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * userAvatarPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAvatarPut(params: {  token?: string; payloadData?: UserAvatarPayload; }, options: any = {}) {
        return UserApiFp.userAvatarPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyPost
     * @param payloadData  (def)
     */
    userEmailVerifyPost(params: {  payloadData?: UserVerifyEmailCodePayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyResendPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userEmailVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
        return UserApiFp.userLoginPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutCloseotherGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
        return UserApiFp.userMailCheckPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
        return UserApiFp.userPasswordChangePut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
        return UserApiFp.userPasswordChangeTokenPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}) {
        return UserApiFp.userPasswordForgetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordVerifyPost
     * @param payloadData  (def)
     */
    userPasswordVerifyPost(params: {  payloadData?: UserForgetCodePayload; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPingGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
        return UserApiFp.userRegisterPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userStorePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStorePost(params: {  token?: string; payloadData?: UserStorePayload; }, options: any = {}) {
        return UserApiFp.userStorePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
        return UserApiFp.userUpdatePut(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * userAvatarPut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userAvatarPut(params: {  token?: string; payloadData?: UserAvatarPayload; }, options: any = {}) {
            return UserApiFp.userAvatarPut(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyPost
         * @param payloadData  (def)
         */
        userEmailVerifyPost(params: {  payloadData?: UserVerifyEmailCodePayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyResendPost
         * @param payloadData  (def)
         */
        userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyResendPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyTokenGet
         * @param token  (def)
         */
        userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userEmailVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userLoginPost
         * @param payloadData  (def)
         */
        userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
            return UserApiFp.userLoginPost(params, options)(fetch, basePath);
        },
        /**
         * userLogoutCloseotherGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutCloseotherGet(params, options)(fetch, basePath);
        },
        /**
         * userLogoutGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutGet(params, options)(fetch, basePath);
        },
        /**
         * userMailCheckPost
         * @param payloadData  (def)
         */
        userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
            return UserApiFp.userMailCheckPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
            return UserApiFp.userPasswordChangePut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangeTokenPut
         * @param token  (def)
         * @param payloadData  (def)
         */
        userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
            return UserApiFp.userPasswordChangeTokenPut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordForgetPost
         * @param payloadData  (def)
         */
        userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}) {
            return UserApiFp.userPasswordForgetPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyPost
         * @param payloadData  (def)
         */
        userPasswordVerifyPost(params: {  payloadData?: UserForgetCodePayload; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyTokenGet
         * @param token  (def)
         */
        userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userPingGet
         * @param token the security token, get it from login route (def)
         */
        userPingGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPingGet(params, options)(fetch, basePath);
        },
        /**
         * userRegisterPost
         * @param payloadData  (def)
         */
        userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
            return UserApiFp.userRegisterPost(params, options)(fetch, basePath);
        },
        /**
         * userStorePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userStorePost(params: {  token?: string; payloadData?: UserStorePayload; }, options: any = {}) {
            return UserApiFp.userStorePost(params, options)(fetch, basePath);
        },
        /**
         * userUpdatePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
            return UserApiFp.userUpdatePut(params, options)(fetch, basePath);
        },
    };
};

