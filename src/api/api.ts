/**
 * The clickyab.com/crab API
 * The crab api, auto generated
 *
 * OpenAPI spec version: \"0.0.1-pre-alpha\"
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import AAA from "./../services/AAA/index";
import * as querystring from "querystring";
import * as url from "url";
import * as assign from "core-js/library/fn/object/assign";
import "whatwg-fetch";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

export const BASE_PATH = "http://staging.crab.clickyab.ae/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    configuration: object;

    constructor(fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH, configuration: object = {}) {
        this.basePath = basePath;
        this.fetch = fetchFn;
        this.configuration = configuration;
    }
}
        const removeEmpty = (obj) => {
        const objectInstance = JSON.parse(JSON.stringify(obj)); // Clone source oect.

        Object.keys(objectInstance).forEach(key => {
        if (objectInstance[key] && typeof objectInstance[key] === "object")
        objectInstance[key] = removeEmpty(objectInstance[key]);  // Recurse.
        else if (objectInstance[key] === undefined || objectInstance[key] === null) {
        delete objectInstance[key]; // Delete undefined and null.
        }
        else
        objectInstance[key] = objectInstance[key];  // Copy value.
        });

        return objectInstance; // Return new object.
        };
export interface ControllerErrorResponseSimple {
    "error"?: NotAuthorizedError;
}

export interface ControllerNormalResponse {
}

export interface ControllersAddInventoryPayload {
    "pub_ids"?: Array<number>;
}

export interface ControllersAssignInventoryPayload {
    "id"?: number;
    "state"?: string;
}

export interface ControllersAttributesPayload {
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "device"?: Array<string>;
    "iab"?: Array<string>;
    "isp"?: Array<string>;
    "manufacturer"?: Array<string>;
    "os"?: Array<string>;
    "region"?: Array<string>;
}

export interface ControllersAttributesResult {
    "archived_at"?: string;
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "created_at"?: string;
    "daily_budget"?: number;
    "device"?: Array<string>;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "iab"?: Array<string>;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "isp"?: Array<string>;
    "kind"?: string;
    "manufacturer"?: Array<string>;
    "max_bid"?: number;
    "os"?: Array<string>;
    "progress"?: string;
    "region"?: Array<string>;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersAttributesResultInventoryType {
    "InventoryState"?: string;
    "Valid"?: boolean;
}

export interface ControllersBaseResult {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "schedule"?: ControllersBaseResultSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersBaseResultSchedule {
    "campaign_id"?: number;
    "h00"?: ControllersBaseResultScheduleH00;
    "h01"?: ControllersBaseResultScheduleH00;
    "h02"?: ControllersBaseResultScheduleH00;
    "h03"?: ControllersBaseResultScheduleH00;
    "h04"?: ControllersBaseResultScheduleH00;
    "h05"?: ControllersBaseResultScheduleH00;
    "h06"?: ControllersBaseResultScheduleH00;
    "h07"?: ControllersBaseResultScheduleH00;
    "h08"?: ControllersBaseResultScheduleH00;
    "h09"?: ControllersBaseResultScheduleH00;
    "h10"?: ControllersBaseResultScheduleH00;
    "h11"?: ControllersBaseResultScheduleH00;
    "h12"?: ControllersBaseResultScheduleH00;
    "h13"?: ControllersBaseResultScheduleH00;
    "h14"?: ControllersBaseResultScheduleH00;
    "h15"?: ControllersBaseResultScheduleH00;
    "h16"?: ControllersBaseResultScheduleH00;
    "h17"?: ControllersBaseResultScheduleH00;
    "h18"?: ControllersBaseResultScheduleH00;
    "h19"?: ControllersBaseResultScheduleH00;
    "h20"?: ControllersBaseResultScheduleH00;
    "h21"?: ControllersBaseResultScheduleH00;
    "h22"?: ControllersBaseResultScheduleH00;
    "h23"?: ControllersBaseResultScheduleH00;
    "id"?: number;
    "updated_at"?: string;
}

export interface ControllersBaseResultScheduleH00 {
    "String"?: string;
    "Valid"?: boolean;
}

export interface ControllersBrowserResponse extends Array<ControllersBrowserResponseInner> {
}

export interface ControllersBrowserResponseInner {
    "created_at"?: string;
    "deleted_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersBudgetPayload {
    "daily_budget"?: number;
    "exchange"?: string;
    "max_bid"?: number;
    "receivers"?: Array<number>;
    "strategy"?: string;
    "total_budget"?: number;
}

export interface ControllersCampaignBase {
    "end_at"?: string;
    "schedule"?: ControllersCampaignBaseSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface ControllersCampaignBaseSchedule {
    "h00"?: string;
    "h01"?: string;
    "h02"?: string;
    "h03"?: string;
    "h04"?: string;
    "h05"?: string;
    "h06"?: string;
    "h07"?: string;
    "h08"?: string;
    "h09"?: string;
    "h10"?: string;
    "h11"?: string;
    "h12"?: string;
    "h13"?: string;
    "h14"?: string;
    "h15"?: string;
    "h16"?: string;
    "h17"?: string;
    "h18"?: string;
    "h19"?: string;
    "h20"?: string;
    "h21"?: string;
    "h22"?: string;
    "h23"?: string;
}

export interface ControllersCampaignGetResponse {
    "archived_at"?: string;
    "attributes"?: ControllersCampaignGetResponseAttributes;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory"?: ControllersCampaignGetResponseInventory;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "receivers"?: Array<ControllersCampaignGetResponseReceivers>;
    "schedule"?: ControllersCampaignGetResponseSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersCampaignGetResponseAttributes {
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "device"?: Array<string>;
    "iab"?: Array<string>;
    "isp"?: Array<string>;
    "manufacturer"?: Array<string>;
    "os"?: Array<string>;
    "region"?: Array<string>;
}

export interface ControllersCampaignGetResponseInventory {
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "publisher_count"?: number;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersCampaignGetResponseReceivers {
    "email"?: string;
    "id"?: number;
}

export interface ControllersCampaignGetResponseSchedule {
    "h00"?: ControllersBaseResultScheduleH00;
    "h01"?: ControllersBaseResultScheduleH00;
    "h02"?: ControllersBaseResultScheduleH00;
    "h03"?: ControllersBaseResultScheduleH00;
    "h04"?: ControllersBaseResultScheduleH00;
    "h05"?: ControllersBaseResultScheduleH00;
    "h06"?: ControllersBaseResultScheduleH00;
    "h07"?: ControllersBaseResultScheduleH00;
    "h08"?: ControllersBaseResultScheduleH00;
    "h09"?: ControllersBaseResultScheduleH00;
    "h10"?: ControllersBaseResultScheduleH00;
    "h11"?: ControllersBaseResultScheduleH00;
    "h12"?: ControllersBaseResultScheduleH00;
    "h13"?: ControllersBaseResultScheduleH00;
    "h14"?: ControllersBaseResultScheduleH00;
    "h15"?: ControllersBaseResultScheduleH00;
    "h16"?: ControllersBaseResultScheduleH00;
    "h17"?: ControllersBaseResultScheduleH00;
    "h18"?: ControllersBaseResultScheduleH00;
    "h19"?: ControllersBaseResultScheduleH00;
    "h20"?: ControllersBaseResultScheduleH00;
    "h21"?: ControllersBaseResultScheduleH00;
    "h22"?: ControllersBaseResultScheduleH00;
    "h23"?: ControllersBaseResultScheduleH00;
}

export interface ControllersCatResponse extends Array<ControllersCatResponseInner> {
}

export interface ControllersCatResponseInner {
    "deleted_at"?: ControllersCatResponseInnerDeletedAt;
    "description"?: string;
    "name"?: string;
}

export interface ControllersCatResponseInnerDeletedAt {
    "Time"?: string;
    "Valid"?: boolean;
}

export interface ControllersChangeCampaignStatus {
    "status"?: string;
}

export interface ControllersChangeLabelPayload {
    "label"?: string;
}

export interface ControllersChangeStatusPayload {
    "status"?: string;
}

export interface ControllersCopyCampaignPayload {
    "title"?: string;
}

export interface ControllersCreateCampaignPayload {
    "end_at"?: string;
    "kind"?: string;
    "schedule"?: ControllersCampaignBaseSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface ControllersCreateInventoryPayload {
    "label"?: string;
    "pub_ids"?: Array<number>;
}

export interface ControllersCreateNativePayload {
    "assets"?: ControllersCreateNativePayloadAssets;
    "attributes"?: { [key: string]: string; };
    "campaign_id"?: number;
    "max_bid"?: number;
    "name"?: string;
    "url"?: string;
}

export interface ControllersCreateNativePayloadAssets {
    "cta"?: Array<ControllersNativeAssetPayloadCta>;
    "description"?: Array<ControllersNativeAssetPayloadCta>;
    "downloads"?: Array<ControllersNativeAssetPayloadDownloads>;
    "icon"?: Array<ControllersNativeAssetPayloadCta>;
    "images"?: Array<ControllersNativeAssetPayloadCta>;
    "logo"?: Array<ControllersNativeAssetPayloadCta>;
    "phone"?: Array<ControllersNativeAssetPayloadCta>;
    "price"?: Array<ControllersNativeAssetPayloadPrice>;
    "rating"?: Array<ControllersNativeAssetPayloadPrice>;
    "sale_price"?: Array<ControllersNativeAssetPayloadPrice>;
    "title"?: Array<ControllersNativeAssetPayloadCta>;
    "video"?: Array<ControllersNativeAssetPayloadCta>;
}

export interface ControllersDuplicateInventoryPayload {
    "id"?: number;
}

export interface ControllersEditNativePayload {
    "assets"?: ControllersCreateNativePayloadAssets;
    "attributes"?: { [key: string]: string; };
    "max_bid"?: number;
    "name"?: string;
    "url"?: string;
}

export interface ControllersFinalizeResult {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersGetCreativeResp extends Array<string> {
}

export interface ControllersGetGateResp extends Array<ControllersGetGateRespInner> {
}

export interface ControllersGetGateRespInner {
    "created_at"?: string;
    "id"?: number;
    "is_default"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersGetVideoResponse {
    "ready"?: string;
}

export interface ControllersGraphChartallData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartallResponse {
    "data"?: Array<ControllersGraphChartallResponseData>;
    "format"?: string;
    "from"?: string;
    "to"?: string;
    "type"?: string;
}

export interface ControllersGraphChartallResponseData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartdailyData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartdailyResponse {
    "data"?: Array<ControllersGraphChartallResponseData>;
    "format"?: string;
    "from"?: string;
    "to"?: string;
    "type"?: string;
}

export interface ControllersInitPaymentPayload {
    "charge_amount"?: number;
    "gate_way"?: number;
}

export interface ControllersIspResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersIspResponseInner {
    "created_at"?: string;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersListBasePublisherStatisticsDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListBasePublisherStatisticsDefResponseColumns {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface ControllersListBasePublisherStatisticsResponse {
    "data"?: Array<ControllersListBasePublisherStatisticsResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListBasePublisherStatisticsResponseData {
    "avg_imp"?: number;
    "count"?: number;
    "domain"?: string;
    "exchange_count"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
}

export interface ControllersListCampaigndailyDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListCampaigndailyResponse {
    "data"?: Array<ControllersListCampaigndailyResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCampaigndailyResponseData {
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "date"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface ControllersListCampaignsDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListCampaignsResponse {
    "data"?: Array<ControllersListCampaignsResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCampaignsResponseData {
    "_actions"?: string;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "created_at"?: string;
    "creative"?: number;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "today_click"?: number;
    "today_ctr"?: number;
    "today_imp"?: number;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_click"?: number;
    "total_imp"?: number;
    "total_spend"?: number;
}

export interface ControllersListCreativecampaignreportDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListCreativecampaignreportResponse {
    "data"?: Array<ControllersListCreativecampaignreportResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCreativecampaignreportResponseData {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "created_at"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "name"?: string;
    "spend"?: number;
    "status"?: string;
    "type"?: string;
}

export interface ControllersListInventoryDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListInventoryResponse {
    "data"?: Array<ControllersListInventoryResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListInventoryResponseData {
    "_actions"?: string;
    "attached"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersListInvpublisherDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListInvpublisherResponse {
    "data"?: Array<ControllersListInvpublisherResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListInvpublisherResponseData {
    "_actions"?: string;
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface ControllersListPublisherDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListPublisherResponse {
    "data"?: Array<ControllersListInvpublisherResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListPublisherdetailsDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListPublisherdetailsResponse {
    "data"?: Array<ControllersListPublisherdetailsResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListPublisherdetailsResponseData {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "domain"?: ControllersBaseResultScheduleH00;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface ControllersManufacturers extends Array<ControllersManufacturersInner> {
}

export interface ControllersManufacturersInner {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersNativeAssetPayload {
    "cta"?: Array<ControllersNativeAssetPayloadCta>;
    "description"?: Array<ControllersNativeAssetPayloadCta>;
    "downloads"?: Array<ControllersNativeAssetPayloadDownloads>;
    "icon"?: Array<ControllersNativeAssetPayloadCta>;
    "images"?: Array<ControllersNativeAssetPayloadCta>;
    "logo"?: Array<ControllersNativeAssetPayloadCta>;
    "phone"?: Array<ControllersNativeAssetPayloadCta>;
    "price"?: Array<ControllersNativeAssetPayloadPrice>;
    "rating"?: Array<ControllersNativeAssetPayloadPrice>;
    "sale_price"?: Array<ControllersNativeAssetPayloadPrice>;
    "title"?: Array<ControllersNativeAssetPayloadCta>;
    "video"?: Array<ControllersNativeAssetPayloadCta>;
}

export interface ControllersNativeAssetPayloadCta {
    "label"?: string;
    "val"?: string;
}

export interface ControllersNativeAssetPayloadDownloads {
    "label"?: string;
    "val"?: number;
}

export interface ControllersNativeAssetPayloadPrice {
    "label"?: string;
    "val"?: number;
}

export interface ControllersOsResponse extends Array<ControllersManufacturersInner> {
}

export interface ControllersPlatformResponse extends Array<ControllersManufacturersInner> {
}

export interface ControllersRegisterBankSnapPayload {
    "amount"?: number;
    "trace_number"?: number;
}

export interface ControllersRemoveInventoryPayload {
    "pub_ids"?: Array<number>;
}

export interface ControllersUpdateResult {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "schedule"?: ControllersBaseResultSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersUploadResponse {
    "src"?: string;
}

export interface LocationCities extends Array<LocationCitiesInner> {
}

export interface LocationCitiesInner {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCity {
    "id"?: number;
    "name"?: string;
    "province_id"?: number;
}

export interface LocationCountries extends Array<LocationCountriesInner> {
}

export interface LocationCountriesInner {
    "id"?: number;
    "name"?: string;
}

export interface LocationCountry {
    "id"?: number;
    "name"?: string;
}

export interface LocationProvince {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface LocationProvinces extends Array<LocationProvincesInner> {
}

export interface LocationProvincesInner {
    "country_id"?: number;
    "id"?: number;
    "name"?: string;
}

export interface NotAuthorized {
    "error"?: NotAuthorizedError;
}

export interface NotAuthorizedError {
    "params"?: Array<string>;
    "text"?: string;
}

export interface OrmAssetStatus {
}

export interface OrmBankReasonState {
}

export interface OrmBankSnap {
    "amount"?: number;
    "checked_by"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "pay_amount"?: number;
    "status"?: string;
    "trace_number"?: number;
    "updated_at"?: string;
    "user_id"?: number;
    "vat"?: number;
}

export interface OrmBankSnapCheckStatus {
}

export interface OrmBilling {
    "amount"?: number;
    "balance"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "income_id"?: number;
    "pay_amount"?: number;
    "pay_model"?: string;
    "user_id"?: number;
    "vat"?: number;
}

export interface OrmBrowser {
    "created_at"?: string;
    "deleted_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmCampaign {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmCampaignDaily {
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "date"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface OrmCampaignDetails {
    "_actions"?: string;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "created_at"?: string;
    "creative"?: number;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "today_click"?: number;
    "today_ctr"?: number;
    "today_imp"?: number;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_click"?: number;
    "total_imp"?: number;
    "total_spend"?: number;
}

export interface OrmCampaignKind {
}

export interface OrmCampaignProgress {
    "avg_cpc"?: number;
    "click"?: number;
    "ctr"?: number;
    "daily_budget"?: number;
    "end_at"?: string;
    "imp"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "total_budget"?: number;
    "total_spend"?: number;
}

export interface OrmCategory {
    "deleted_at"?: ControllersCatResponseInnerDeletedAt;
    "description"?: string;
    "name"?: string;
}

export interface OrmCreative {
    "archived_at"?: string;
    "attributes"?: { [key: string]: string; };
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "name"?: string;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
    "user_id"?: number;
}

export interface OrmCreativeDataTable {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "created_at"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "name"?: string;
    "spend"?: number;
    "status"?: string;
    "type"?: string;
}

export interface OrmCreativeSaveResult {
    "assets"?: { [key: string]: Array<string>; };
    "creative"?: OrmCreativeSaveResultCreative;
}

export interface OrmCreativeSaveResultCreative {
    "archived_at"?: string;
    "attributes"?: { [key: string]: string; };
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "name"?: string;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
    "user_id"?: number;
}

export interface OrmCreativeStatusType {
}

export interface OrmCreativeTypes {
}

export interface OrmDefaultType {
}

export interface OrmDomain {
    "attributes"?: { [key: string]: string; };
    "created_at"?: string;
    "description"?: ControllersBaseResultScheduleH00;
    "id"?: number;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmDomainStatus {
}

export interface OrmExchangeType {
}

export interface OrmGateway {
    "created_at"?: string;
    "id"?: number;
    "is_default"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmGatewayStatus {
}

export interface OrmISP {
    "created_at"?: string;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmISPKind {
}

export interface OrmInventory {
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmInventoryDataTable {
    "_actions"?: string;
    "attached"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmInventoryState {
}

export interface OrmInventoryStatus {
}

export interface OrmManufacturer {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmNativeFloat {
    "label"?: string;
    "val"?: number;
}

export interface OrmNativeInt {
    "label"?: string;
    "val"?: number;
}

export interface OrmNativeString {
    "label"?: string;
    "val"?: string;
}

export interface OrmNullBankReason {
    "BankReason"?: string;
    "Valid"?: boolean;
}

export interface OrmNullInventoryState {
    "InventoryState"?: string;
    "Valid"?: boolean;
}

export interface OrmOS {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmOnlinePayment {
    "amount"?: number;
    "attr"?: { [key: string]: string; };
    "bank_status"?: number;
    "cid"?: ControllersBaseResultScheduleH00;
    "created_at"?: string;
    "domain_id"?: number;
    "error_reason"?: OrmOnlinePaymentErrorReason;
    "gateway_id"?: number;
    "id"?: number;
    "ref_num"?: ControllersBaseResultScheduleH00;
    "res_num"?: string;
    "status"?: string;
    "trace_number"?: ControllersBaseResultScheduleH00;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmOnlinePaymentErrorReason {
    "BankReason"?: string;
    "Valid"?: boolean;
}

export interface OrmOnlinePaymentStatus {
}

export interface OrmPayModels {
}

export interface OrmPlatform {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmProgress {
}

export interface OrmPublisher {
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface OrmPublisherDataTable {
    "_actions"?: string;
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface OrmPublisherDetails {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "domain"?: ControllersBaseResultScheduleH00;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface OrmPublisherType {
}

export interface OrmPublishersBaseStatistics {
    "avg_imp"?: number;
    "count"?: number;
    "domain"?: string;
    "exchange_count"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
}

export interface OrmReceiver {
    "email"?: string;
    "id"?: number;
}

export interface OrmScheduleSheet {
    "h00"?: ControllersBaseResultScheduleH00;
    "h01"?: ControllersBaseResultScheduleH00;
    "h02"?: ControllersBaseResultScheduleH00;
    "h03"?: ControllersBaseResultScheduleH00;
    "h04"?: ControllersBaseResultScheduleH00;
    "h05"?: ControllersBaseResultScheduleH00;
    "h06"?: ControllersBaseResultScheduleH00;
    "h07"?: ControllersBaseResultScheduleH00;
    "h08"?: ControllersBaseResultScheduleH00;
    "h09"?: ControllersBaseResultScheduleH00;
    "h10"?: ControllersBaseResultScheduleH00;
    "h11"?: ControllersBaseResultScheduleH00;
    "h12"?: ControllersBaseResultScheduleH00;
    "h13"?: ControllersBaseResultScheduleH00;
    "h14"?: ControllersBaseResultScheduleH00;
    "h15"?: ControllersBaseResultScheduleH00;
    "h16"?: ControllersBaseResultScheduleH00;
    "h17"?: ControllersBaseResultScheduleH00;
    "h18"?: ControllersBaseResultScheduleH00;
    "h19"?: ControllersBaseResultScheduleH00;
    "h20"?: ControllersBaseResultScheduleH00;
    "h21"?: ControllersBaseResultScheduleH00;
    "h22"?: ControllersBaseResultScheduleH00;
    "h23"?: ControllersBaseResultScheduleH00;
}

export interface OrmSinglePublisherDataTable {
    "_actions"?: string;
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface OrmStatus {
}

export interface OrmStrategy {
}

export interface PaymentInitPaymentResp {
    "bank_url"?: string;
    "method"?: string;
    "params"?: { [key: string]: string; };
}

export interface PermissionColumn {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface TransT9Base {
    "params"?: Array<string>;
    "text"?: string;
}

export interface UserAvatarPayload {
    "avatar"?: string;
}

export interface UserCallBackPayload {
    "new_password"?: string;
}

export interface UserChangePassword {
    "current_password"?: string;
    "new_password"?: string;
}

export interface UserCheckMailPayload {
    "email"?: string;
}

export interface UserCheckMailResponse {
    "current_domain"?: boolean;
    "domains"?: Array<UserCheckMailResponseDomains>;
}

export interface UserCheckMailResponseDomains {
    "attributes"?: { [key: string]: string; };
    "created_at"?: string;
    "description"?: ControllersBaseResultScheduleH00;
    "id"?: number;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface UserForgetCodePayload {
    "code"?: string;
    "email"?: string;
}

export interface UserForgetPayload {
    "email"?: string;
}

export interface UserLoginPayload {
    "email"?: string;
    "password"?: string;
}

export interface UserRegisterPayload {
    "email"?: string;
    "first_name"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "mobile"?: string;
    "password"?: string;
}

export interface UserResponseLoginOK {
    "account"?: UserResponseLoginOKAccount;
    "token"?: string;
}

export interface UserResponseLoginOKAccount {
    "address"?: string;
    "attributes"?: { [key: string]: string; };
    "avatar"?: string;
    "balance"?: number;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserStorePayload {
    "data"?: { [key: string]: string; };
}

export interface UserUserPayload {
    "address"?: string;
    "cell_phone"?: string;
    "city_id"?: number;
    "economic_code"?: string;
    "first_name"?: string;
    "gender"?: string;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "ssn"?: string;
}

export interface UserUserResponse {
    "address"?: string;
    "attributes"?: { [key: string]: string; };
    "avatar"?: string;
    "balance"?: number;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "province_id"?: number;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserVerifyEmailCodePayload {
    "code"?: string;
    "email"?: string;
}

export interface UserVerifyResendPayload {
    "email"?: string;
}



/**
 * ControllersApi - fetch parameter creator
 */
export const ControllersApiFetchParamCreator = {
    /**
     * @func
     * adCampaignIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    adCampaignIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCampaignIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/campaign/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adCampaignIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param type  param
     * @param name  search the name field param
     * @param p  page number param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param status  param
     * @param c  count per page param
     * @param q  parameter for search param
     */
    adCampaignIdGet(params: {  id: string; token?: string; type?: string; name?: string; p?: string; from?: string; to?: string; sort?: string; status?: string; c?: string; q?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCampaignIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/campaign/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["type"] !== undefined) {
            urlObj.query["type"] = params["type"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adCreativeIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    adCreativeIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCreativeIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/creative/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adNativeIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adNativeIdPut(params: {  id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adNativeIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/native/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adNativePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adNativePost(params: {  token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/native`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetBrowserGet
     * @param token the security token, get it from login route param
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/browser`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetCategoryGet
     * @param token the security token, get it from login route param
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/category`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetIspKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetIspKindGet(params: {  kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetIspKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/isp/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetManufacturersGet
     * @param token the security token, get it from login route param
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/manufacturers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsGet
     * @param token the security token, get it from login route param
     */
    assetOsGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetOsKindGet(params: {  kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetOsKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetPlatformGet
     * @param token the security token, get it from login route param
     */
    assetPlatformGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/platform`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetPlatformKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetPlatformKindGet(params: {  kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetPlatformKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/platform/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignArchiveIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignArchiveIdPatch(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignArchiveIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/archive/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignAttributesIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignAttributesIdPut(params: {  id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignAttributesIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/attributes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignBaseIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignBaseIdPut(params: {  id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignBaseIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/base/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignBudgetIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignBudgetIdPut(params: {  id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignBudgetIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/budget/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCopyIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignCopyIdPatch(params: {  id: string; token?: string; payloadData?: ControllersCopyCampaignPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignCopyIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/copy/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCreatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignCreatePost(params: {  token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCreativeIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignCreativeIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignCreativeIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/creative/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignDailyIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignDailyIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignDailyIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/daily/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignDailyIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param p  page number param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param c  count per page param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     */
    campaignDailyIdGet(params: {  id: string; token?: string; p?: string; to?: string; c?: string; q?: string; from?: string; sort?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignDailyIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/daily/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignFinalizeIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignFinalizeIdPut(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignFinalizeIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/finalize/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGetIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignGetIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGetIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/get/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGraphAllGet
     * @param token the security token, get it from login route param
     * @param kind  param
     * @param ownerEmail  search the owner_email field param
     * @param title  search the title field param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    campaignGraphAllGet(params: {  token?: string; kind?: string; ownerEmail?: string; title?: string; from?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/graph/all`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["ownerEmail"] !== undefined) {
            urlObj.query["owner_email"] = params["ownerEmail"];
        }
        if (params["title"] !== undefined) {
            urlObj.query["title"] = params["title"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGraphDailyIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    campaignGraphDailyIdGet(params: {  id: string; token?: string; from?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGraphDailyIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/graph/daily/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignInventoryIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignInventoryIdPut(params: {  id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignInventoryIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/inventory/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignListDefinitionGet
     * @param token the security token, get it from login route param
     */
    campaignListDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignListGet
     * @param token the security token, get it from login route param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param ownerEmail  search the owner_email field param
     * @param q  parameter for search param
     * @param strategy  param
     * @param c  count per page param
     * @param p  page number param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param status  param
     * @param exchange  param
     * @param title  search the title field param
     * @param sort  param
     * @param kind  param
     */
    campaignListGet(params: {  token?: string; from?: string; ownerEmail?: string; q?: string; strategy?: string; c?: string; p?: string; to?: string; status?: string; exchange?: string; title?: string; sort?: string; kind?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["ownerEmail"] !== undefined) {
            urlObj.query["owner_email"] = params["ownerEmail"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["strategy"] !== undefined) {
            urlObj.query["strategy"] = params["strategy"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["exchange"] !== undefined) {
            urlObj.query["exchange"] = params["exchange"];
        }
        if (params["title"] !== undefined) {
            urlObj.query["title"] = params["title"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignProgressIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignProgressIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignProgressIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/progress/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignPublisherDetailsIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignPublisherDetailsIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignPublisherDetailsIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/publisher-details/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignPublisherDetailsIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param domain  search the domain field param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param p  page number param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param c  count per page param
     */
    campaignPublisherDetailsIdGet(params: {  id: string; token?: string; domain?: string; to?: string; p?: string; q?: string; from?: string; sort?: string; c?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignPublisherDetailsIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/publisher-details/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignStatusIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignStatusIdPatch(params: {  id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignStatusIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/status/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialAddPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialAddPost(params: {  token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/add`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGatewaysGet
     * @param token the security token, get it from login route param
     */
    financialGatewaysGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/gateways`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGet
     * @param token the security token, get it from login route param
     */
    financialGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialPaymentIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    financialPaymentIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling financialPaymentIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/payment/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialPaymentInitPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialPaymentInitPost(params: {  token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/payment/init`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialPaymentReturnBankHashPost
     * @param bank  param
     * @param hash  param
     */
    financialPaymentReturnBankHashPost(params: {  bank: string; hash: string; }, options: any = {}): FetchArgs {
        // verify required parameter "bank" is set
        if (params["bank"] == null) {
            throw new Error("Missing required parameter bank when calling financialPaymentReturnBankHashPost");
        }
        // verify required parameter "hash" is set
        if (params["hash"] == null) {
            throw new Error("Missing required parameter hash when calling financialPaymentReturnBankHashPost");
        }
        const baseUrl = `/financial/payment/return/{bank}/{hash}`
            .replace(`{${"bank"}}`, `${ params["bank"] }`)
            .replace(`{${"hash"}}`, `${ params["hash"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryAddpubIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryAddpubIdPatch(params: {  id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryAddpubIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/addpub/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryBasePublishersStatisticsDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryBasePublishersStatisticsDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/base-publishers/statistics/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryBasePublishersStatisticsGet
     * @param token the security token, get it from login route param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param kind  param
     * @param status  param
     * @param p  page number param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param supplier  search the supplier field param
     * @param c  count per page param
     * @param q  parameter for search param
     * @param name  search the name field param
     * @param domain  search the domain field param
     */
    inventoryBasePublishersStatisticsGet(params: {  token?: string; to?: string; kind?: string; status?: string; p?: string; from?: string; supplier?: string; c?: string; q?: string; name?: string; domain?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/base-publishers/statistics`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["supplier"] !== undefined) {
            urlObj.query["supplier"] = params["supplier"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryCreatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryCreatePost(params: {  token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryDuplicatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryDuplicatePost(params: {  token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/duplicate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryIdPut(params: {  id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryInventoryIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryInventoryIdPatch(params: {  id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryInventoryIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/inventory/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryInventoryListDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryInventoryListDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/inventory/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryInventoryListGet
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param status  param
     * @param sort  param
     * @param label  search the label field param
     * @param p  page number param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    inventoryInventoryListGet(params: {  token?: string; c?: string; status?: string; sort?: string; label?: string; p?: string; q?: string; from?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/inventory/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["label"] !== undefined) {
            urlObj.query["label"] = params["label"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryPublisherListDefinitionGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListGet
     * @param token the security token, get it from login route param
     * @param p  page number param
     * @param sort  param
     * @param kind  param
     * @param status  param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param name  search the name field param
     * @param domain  search the domain field param
     * @param supplier  search the supplier field param
     * @param c  count per page param
     */
    inventoryPublisherListGet(params: {  token?: string; p?: string; sort?: string; kind?: string; status?: string; q?: string; from?: string; to?: string; name?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["supplier"] !== undefined) {
            urlObj.query["supplier"] = params["supplier"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListSingleIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    inventoryPublisherListSingleIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPublisherListSingleIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list/single/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListSingleIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param domain  search the domain field param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param kind  param
     * @param status  param
     * @param p  page number param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param c  count per page param
     * @param name  search the name field param
     * @param q  parameter for search param
     * @param supplier  search the supplier field param
     */
    inventoryPublisherListSingleIdGet(params: {  id: string; token?: string; domain?: string; from?: string; kind?: string; status?: string; p?: string; to?: string; sort?: string; c?: string; name?: string; q?: string; supplier?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPublisherListSingleIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list/single/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["supplier"] !== undefined) {
            urlObj.query["supplier"] = params["supplier"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryRemovepubIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryRemovepubIdPatch(params: {  id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryRemovepubIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/removepub/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadModuleModulePost
     * @param module  param
     * @param token the security token, get it from login route param
     */
    uploadModuleModulePost(params: {  module: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "module" is set
        if (params["module"] == null) {
            throw new Error("Missing required parameter module when calling uploadModuleModulePost");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/module/{module}`
            .replace(`{${"module"}}`, `${ params["module"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadVideoIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    uploadVideoIdGet(params: {  id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling uploadVideoIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/video/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ControllersApi - functional programming interface
 */
export const ControllersApiFp = {
    /**
     * adCampaignIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCampaignIdDefinitionGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCreativecampaignreportDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.adCampaignIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * adCampaignIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param type  (def)
     * @param name  search the name field (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param status  (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     */
    adCampaignIdGet(params: { id: string; token?: string; type?: string; name?: string; p?: string; from?: string; to?: string; sort?: string; status?: string; c?: string; q?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCreativecampaignreportResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.adCampaignIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * adCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCreativeIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        const fetchArgs = ControllersApiFetchParamCreator.adCreativeIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * adNativeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativeIdPut(params: { id: string; token?: string; payloadData?: ControllersEditNativePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        const fetchArgs = ControllersApiFetchParamCreator.adNativeIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * adNativePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativePost(params: { token?: string; payloadData?: ControllersCreateNativePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        const fetchArgs = ControllersApiFetchParamCreator.adNativePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBrowserResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetBrowserGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCatResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetCategoryGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetIspKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetIspKindGet(params: { kind: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersIspResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetIspKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersManufacturers> {
        const fetchArgs = ControllersApiFetchParamCreator.assetManufacturersGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetOsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetOsKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetOsKindGet(params: { kind: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetOsKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetPlatformGet
     * @param token the security token, get it from login route (def)
     */
    assetPlatformGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersPlatformResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetPlatformGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * assetPlatformKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetPlatformKindGet(params: { kind: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersPlatformResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.assetPlatformKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignArchiveIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignArchiveIdPatch(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignArchiveIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignAttributesIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignAttributesIdPut(params: { id: string; token?: string; payloadData?: ControllersAttributesPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersAttributesResult> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignAttributesIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignBaseIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBaseIdPut(params: { id: string; token?: string; payloadData?: ControllersCampaignBase;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersUpdateResult> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignBaseIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignBudgetIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBudgetIdPut(params: { id: string; token?: string; payloadData?: ControllersBudgetPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignBudgetIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignCopyIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCopyIdPatch(params: { id: string; token?: string; payloadData?: ControllersCopyCampaignPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignCopyIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCreatePost(params: { token?: string; payloadData?: ControllersCreateCampaignPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBaseResult> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignCreatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignCreativeIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetCreativeResp> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignCreativeIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignDailyIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignDailyIdDefinitionGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaigndailyDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignDailyIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param p  page number (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     */
    campaignDailyIdGet(params: { id: string; token?: string; p?: string; to?: string; c?: string; q?: string; from?: string; sort?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaigndailyResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignDailyIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignFinalizeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignFinalizeIdPut(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersFinalizeResult> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignFinalizeIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignGetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCampaignGetResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignGetIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignGraphAllGet
     * @param token the security token, get it from login route (def)
     * @param kind  (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param title  search the title field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignGraphAllGet(params: { token?: string; kind?: string; ownerEmail?: string; title?: string; from?: string; to?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGraphChartallResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignGraphAllGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignGraphDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignGraphDailyIdGet(params: { id: string; token?: string; from?: string; to?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGraphChartdailyResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignGraphDailyIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignInventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignInventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersAssignInventoryPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignInventoryIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    campaignListDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaignsDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignListGet
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param q  parameter for search (def)
     * @param strategy  (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param status  (def)
     * @param exchange  (def)
     * @param title  search the title field (def)
     * @param sort  (def)
     * @param kind  (def)
     */
    campaignListGet(params: { token?: string; from?: string; ownerEmail?: string; q?: string; strategy?: string; c?: string; p?: string; to?: string; status?: string; exchange?: string; title?: string; sort?: string; kind?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaignsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignProgressIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignProgressIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaignProgress> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignProgressIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignPublisherDetailsIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignPublisherDetailsIdDefinitionGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherdetailsDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignPublisherDetailsIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignPublisherDetailsIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param domain  search the domain field (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param c  count per page (def)
     */
    campaignPublisherDetailsIdGet(params: { id: string; token?: string; domain?: string; to?: string; p?: string; q?: string; from?: string; sort?: string; c?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherdetailsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignPublisherDetailsIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * campaignStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeCampaignStatus;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.campaignStatusIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * financialAddPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialAddPost(params: { token?: string; payloadData?: ControllersRegisterBankSnapPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmBankSnap> {
        const fetchArgs = ControllersApiFetchParamCreator.financialAddPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * financialGatewaysGet
     * @param token the security token, get it from login route (def)
     */
    financialGatewaysGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetGateResp> {
        const fetchArgs = ControllersApiFetchParamCreator.financialGatewaysGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * financialGet
     * @param token the security token, get it from login route (def)
     */
    financialGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmBilling> {
        const fetchArgs = ControllersApiFetchParamCreator.financialGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * financialPaymentIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    financialPaymentIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmOnlinePayment> {
        const fetchArgs = ControllersApiFetchParamCreator.financialPaymentIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * financialPaymentInitPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialPaymentInitPost(params: { token?: string; payloadData?: ControllersInitPaymentPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentInitPaymentResp> {
        const fetchArgs = ControllersApiFetchParamCreator.financialPaymentInitPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * financialPaymentReturnBankHashPost
     * @param bank  (def)
     * @param hash  (def)
     */
    financialPaymentReturnBankHashPost(params: { bank: string; hash: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ControllersApiFetchParamCreator.financialPaymentReturnBankHashPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryAddpubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryAddpubIdPatch(params: { id: string; token?: string; payloadData?: ControllersAddInventoryPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryAddpubIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryBasePublishersStatisticsDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryBasePublishersStatisticsDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListBasePublisherStatisticsDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryBasePublishersStatisticsDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryBasePublishersStatisticsGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     * @param status  (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     * @param name  search the name field (def)
     * @param domain  search the domain field (def)
     */
    inventoryBasePublishersStatisticsGet(params: { token?: string; to?: string; kind?: string; status?: string; p?: string; from?: string; supplier?: string; c?: string; q?: string; name?: string; domain?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListBasePublisherStatisticsResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryBasePublishersStatisticsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryCreatePost(params: { token?: string; payloadData?: ControllersCreateInventoryPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryCreatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryDuplicatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryDuplicatePost(params: { token?: string; payloadData?: ControllersDuplicateInventoryPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryDuplicatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeLabelPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryInventoryIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryInventoryIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryInventoryIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryInventoryListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryInventoryListDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInventoryDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryInventoryListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryInventoryListGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param status  (def)
     * @param sort  (def)
     * @param label  search the label field (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    inventoryInventoryListGet(params: { token?: string; c?: string; status?: string; sort?: string; label?: string; p?: string; q?: string; from?: string; to?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInventoryResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryInventoryListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPublisherListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListDefinitionGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPublisherListGet
     * @param token the security token, get it from login route (def)
     * @param p  page number (def)
     * @param sort  (def)
     * @param kind  (def)
     * @param status  (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param name  search the name field (def)
     * @param domain  search the domain field (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     */
    inventoryPublisherListGet(params: { token?: string; p?: string; sort?: string; kind?: string; status?: string; q?: string; from?: string; to?: string; name?: string; domain?: string; supplier?: string; c?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPublisherListSingleIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListSingleIdDefinitionGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInvpublisherDefResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListSingleIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryPublisherListSingleIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param domain  search the domain field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     * @param status  (def)
     * @param p  page number (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param c  count per page (def)
     * @param name  search the name field (def)
     * @param q  parameter for search (def)
     * @param supplier  search the supplier field (def)
     */
    inventoryPublisherListSingleIdGet(params: { id: string; token?: string; domain?: string; from?: string; kind?: string; status?: string; p?: string; to?: string; sort?: string; c?: string; name?: string; q?: string; supplier?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInvpublisherResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListSingleIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * inventoryRemovepubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryRemovepubIdPatch(params: { id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        const fetchArgs = ControllersApiFetchParamCreator.inventoryRemovepubIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadModuleModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModuleModulePost(params: { module: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersUploadResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadModuleModulePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * uploadVideoIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadVideoIdGet(params: { id: string; token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetVideoResponse> {
        const fetchArgs = ControllersApiFetchParamCreator.uploadVideoIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * ControllersApi - object-oriented interface
 */
export class ControllersApi extends BaseAPI {
    /**
     * adCampaignIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCampaignIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.adCampaignIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * adCampaignIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param type  (def)
     * @param name  search the name field (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param status  (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     */
    adCampaignIdGet(params: {  id: string; token?: string; type?: string; name?: string; p?: string; from?: string; to?: string; sort?: string; status?: string; c?: string; q?: string; }, options: any = {}) {
        return ControllersApiFp.adCampaignIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * adCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCreativeIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.adCreativeIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * adNativeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativeIdPut(params: {  id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}) {
        return ControllersApiFp.adNativeIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * adNativePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativePost(params: {  token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}) {
        return ControllersApiFp.adNativePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetBrowserGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetCategoryGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetIspKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetIspKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetIspKindGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetManufacturersGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetOsKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetOsKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsKindGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetPlatformGet
     * @param token the security token, get it from login route (def)
     */
    assetPlatformGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.assetPlatformGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * assetPlatformKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetPlatformKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetPlatformKindGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignArchiveIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignArchiveIdPatch(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignArchiveIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignAttributesIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignAttributesIdPut(params: {  id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}) {
        return ControllersApiFp.campaignAttributesIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignBaseIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBaseIdPut(params: {  id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}) {
        return ControllersApiFp.campaignBaseIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignBudgetIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBudgetIdPut(params: {  id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}) {
        return ControllersApiFp.campaignBudgetIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignCopyIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCopyIdPatch(params: {  id: string; token?: string; payloadData?: ControllersCopyCampaignPayload; }, options: any = {}) {
        return ControllersApiFp.campaignCopyIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCreatePost(params: {  token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}) {
        return ControllersApiFp.campaignCreatePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignCreativeIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignCreativeIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignDailyIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignDailyIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignDailyIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param p  page number (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     */
    campaignDailyIdGet(params: {  id: string; token?: string; p?: string; to?: string; c?: string; q?: string; from?: string; sort?: string; }, options: any = {}) {
        return ControllersApiFp.campaignDailyIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignFinalizeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignFinalizeIdPut(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignFinalizeIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignGetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGetIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignGraphAllGet
     * @param token the security token, get it from login route (def)
     * @param kind  (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param title  search the title field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignGraphAllGet(params: {  token?: string; kind?: string; ownerEmail?: string; title?: string; from?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGraphAllGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignGraphDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignGraphDailyIdGet(params: {  id: string; token?: string; from?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGraphDailyIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignInventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignInventoryIdPut(params: {  id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.campaignInventoryIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    campaignListDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignListDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignListGet
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param q  parameter for search (def)
     * @param strategy  (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param status  (def)
     * @param exchange  (def)
     * @param title  search the title field (def)
     * @param sort  (def)
     * @param kind  (def)
     */
    campaignListGet(params: {  token?: string; from?: string; ownerEmail?: string; q?: string; strategy?: string; c?: string; p?: string; to?: string; status?: string; exchange?: string; title?: string; sort?: string; kind?: string; }, options: any = {}) {
        return ControllersApiFp.campaignListGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignProgressIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignProgressIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignProgressIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignPublisherDetailsIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignPublisherDetailsIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignPublisherDetailsIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignPublisherDetailsIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param domain  search the domain field (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param c  count per page (def)
     */
    campaignPublisherDetailsIdGet(params: {  id: string; token?: string; domain?: string; to?: string; p?: string; q?: string; from?: string; sort?: string; c?: string; }, options: any = {}) {
        return ControllersApiFp.campaignPublisherDetailsIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * campaignStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignStatusIdPatch(params: {  id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}) {
        return ControllersApiFp.campaignStatusIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * financialAddPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialAddPost(params: {  token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}) {
        return ControllersApiFp.financialAddPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * financialGatewaysGet
     * @param token the security token, get it from login route (def)
     */
    financialGatewaysGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.financialGatewaysGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * financialGet
     * @param token the security token, get it from login route (def)
     */
    financialGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.financialGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * financialPaymentIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    financialPaymentIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.financialPaymentIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * financialPaymentInitPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialPaymentInitPost(params: {  token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}) {
        return ControllersApiFp.financialPaymentInitPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * financialPaymentReturnBankHashPost
     * @param bank  (def)
     * @param hash  (def)
     */
    financialPaymentReturnBankHashPost(params: {  bank: string; hash: string; }, options: any = {}) {
        return ControllersApiFp.financialPaymentReturnBankHashPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryAddpubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryAddpubIdPatch(params: {  id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryAddpubIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryBasePublishersStatisticsDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryBasePublishersStatisticsDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryBasePublishersStatisticsDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryBasePublishersStatisticsGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     * @param status  (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     * @param name  search the name field (def)
     * @param domain  search the domain field (def)
     */
    inventoryBasePublishersStatisticsGet(params: {  token?: string; to?: string; kind?: string; status?: string; p?: string; from?: string; supplier?: string; c?: string; q?: string; name?: string; domain?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryBasePublishersStatisticsGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryCreatePost(params: {  token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryCreatePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryDuplicatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryDuplicatePost(params: {  token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryDuplicatePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryIdPut(params: {  id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryIdPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryInventoryIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryInventoryIdPatch(params: {  id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryInventoryIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryInventoryListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryInventoryListDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryInventoryListDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryInventoryListGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param status  (def)
     * @param sort  (def)
     * @param label  search the label field (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    inventoryInventoryListGet(params: {  token?: string; c?: string; status?: string; sort?: string; label?: string; p?: string; q?: string; from?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryInventoryListGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPublisherListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListDefinitionGet(params: {  token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPublisherListGet
     * @param token the security token, get it from login route (def)
     * @param p  page number (def)
     * @param sort  (def)
     * @param kind  (def)
     * @param status  (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param name  search the name field (def)
     * @param domain  search the domain field (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     */
    inventoryPublisherListGet(params: {  token?: string; p?: string; sort?: string; kind?: string; status?: string; q?: string; from?: string; to?: string; name?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPublisherListSingleIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListSingleIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListSingleIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryPublisherListSingleIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param domain  search the domain field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     * @param status  (def)
     * @param p  page number (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param c  count per page (def)
     * @param name  search the name field (def)
     * @param q  parameter for search (def)
     * @param supplier  search the supplier field (def)
     */
    inventoryPublisherListSingleIdGet(params: {  id: string; token?: string; domain?: string; from?: string; kind?: string; status?: string; p?: string; to?: string; sort?: string; c?: string; name?: string; q?: string; supplier?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListSingleIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * inventoryRemovepubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryRemovepubIdPatch(params: {  id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryRemovepubIdPatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadModuleModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModuleModulePost(params: {  module: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadModuleModulePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * uploadVideoIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadVideoIdGet(params: {  id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadVideoIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * ControllersApi - factory interface
 */
export const ControllersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * adCampaignIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        adCampaignIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.adCampaignIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * adCampaignIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param type  (def)
         * @param name  search the name field (def)
         * @param p  page number (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param status  (def)
         * @param c  count per page (def)
         * @param q  parameter for search (def)
         */
        adCampaignIdGet(params: {  id: string; token?: string; type?: string; name?: string; p?: string; from?: string; to?: string; sort?: string; status?: string; c?: string; q?: string; }, options: any = {}) {
            return ControllersApiFp.adCampaignIdGet(params, options)(fetch, basePath);
        },
        /**
         * adCreativeIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        adCreativeIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.adCreativeIdGet(params, options)(fetch, basePath);
        },
        /**
         * adNativeIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adNativeIdPut(params: {  id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}) {
            return ControllersApiFp.adNativeIdPut(params, options)(fetch, basePath);
        },
        /**
         * adNativePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adNativePost(params: {  token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}) {
            return ControllersApiFp.adNativePost(params, options)(fetch, basePath);
        },
        /**
         * assetBrowserGet
         * @param token the security token, get it from login route (def)
         */
        assetBrowserGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetBrowserGet(params, options)(fetch, basePath);
        },
        /**
         * assetCategoryGet
         * @param token the security token, get it from login route (def)
         */
        assetCategoryGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetCategoryGet(params, options)(fetch, basePath);
        },
        /**
         * assetIspKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetIspKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetIspKindGet(params, options)(fetch, basePath);
        },
        /**
         * assetManufacturersGet
         * @param token the security token, get it from login route (def)
         */
        assetManufacturersGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetManufacturersGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsGet
         * @param token the security token, get it from login route (def)
         */
        assetOsGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetOsKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsKindGet(params, options)(fetch, basePath);
        },
        /**
         * assetPlatformGet
         * @param token the security token, get it from login route (def)
         */
        assetPlatformGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.assetPlatformGet(params, options)(fetch, basePath);
        },
        /**
         * assetPlatformKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetPlatformKindGet(params: {  kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetPlatformKindGet(params, options)(fetch, basePath);
        },
        /**
         * campaignArchiveIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignArchiveIdPatch(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignArchiveIdPatch(params, options)(fetch, basePath);
        },
        /**
         * campaignAttributesIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignAttributesIdPut(params: {  id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}) {
            return ControllersApiFp.campaignAttributesIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignBaseIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignBaseIdPut(params: {  id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}) {
            return ControllersApiFp.campaignBaseIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignBudgetIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignBudgetIdPut(params: {  id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}) {
            return ControllersApiFp.campaignBudgetIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignCopyIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignCopyIdPatch(params: {  id: string; token?: string; payloadData?: ControllersCopyCampaignPayload; }, options: any = {}) {
            return ControllersApiFp.campaignCopyIdPatch(params, options)(fetch, basePath);
        },
        /**
         * campaignCreatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignCreatePost(params: {  token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}) {
            return ControllersApiFp.campaignCreatePost(params, options)(fetch, basePath);
        },
        /**
         * campaignCreativeIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignCreativeIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignCreativeIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignDailyIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignDailyIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignDailyIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignDailyIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param p  page number (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param c  count per page (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         */
        campaignDailyIdGet(params: {  id: string; token?: string; p?: string; to?: string; c?: string; q?: string; from?: string; sort?: string; }, options: any = {}) {
            return ControllersApiFp.campaignDailyIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignFinalizeIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignFinalizeIdPut(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignFinalizeIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignGetIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignGetIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGetIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignGraphAllGet
         * @param token the security token, get it from login route (def)
         * @param kind  (def)
         * @param ownerEmail  search the owner_email field (def)
         * @param title  search the title field (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        campaignGraphAllGet(params: {  token?: string; kind?: string; ownerEmail?: string; title?: string; from?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGraphAllGet(params, options)(fetch, basePath);
        },
        /**
         * campaignGraphDailyIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        campaignGraphDailyIdGet(params: {  id: string; token?: string; from?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGraphDailyIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignInventoryIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignInventoryIdPut(params: {  id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.campaignInventoryIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        campaignListDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignListGet
         * @param token the security token, get it from login route (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param ownerEmail  search the owner_email field (def)
         * @param q  parameter for search (def)
         * @param strategy  (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param status  (def)
         * @param exchange  (def)
         * @param title  search the title field (def)
         * @param sort  (def)
         * @param kind  (def)
         */
        campaignListGet(params: {  token?: string; from?: string; ownerEmail?: string; q?: string; strategy?: string; c?: string; p?: string; to?: string; status?: string; exchange?: string; title?: string; sort?: string; kind?: string; }, options: any = {}) {
            return ControllersApiFp.campaignListGet(params, options)(fetch, basePath);
        },
        /**
         * campaignProgressIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignProgressIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignProgressIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignPublisherDetailsIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignPublisherDetailsIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignPublisherDetailsIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignPublisherDetailsIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param domain  search the domain field (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param c  count per page (def)
         */
        campaignPublisherDetailsIdGet(params: {  id: string; token?: string; domain?: string; to?: string; p?: string; q?: string; from?: string; sort?: string; c?: string; }, options: any = {}) {
            return ControllersApiFp.campaignPublisherDetailsIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignStatusIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignStatusIdPatch(params: {  id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}) {
            return ControllersApiFp.campaignStatusIdPatch(params, options)(fetch, basePath);
        },
        /**
         * financialAddPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialAddPost(params: {  token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}) {
            return ControllersApiFp.financialAddPost(params, options)(fetch, basePath);
        },
        /**
         * financialGatewaysGet
         * @param token the security token, get it from login route (def)
         */
        financialGatewaysGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.financialGatewaysGet(params, options)(fetch, basePath);
        },
        /**
         * financialGet
         * @param token the security token, get it from login route (def)
         */
        financialGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.financialGet(params, options)(fetch, basePath);
        },
        /**
         * financialPaymentIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        financialPaymentIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.financialPaymentIdGet(params, options)(fetch, basePath);
        },
        /**
         * financialPaymentInitPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialPaymentInitPost(params: {  token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}) {
            return ControllersApiFp.financialPaymentInitPost(params, options)(fetch, basePath);
        },
        /**
         * financialPaymentReturnBankHashPost
         * @param bank  (def)
         * @param hash  (def)
         */
        financialPaymentReturnBankHashPost(params: {  bank: string; hash: string; }, options: any = {}) {
            return ControllersApiFp.financialPaymentReturnBankHashPost(params, options)(fetch, basePath);
        },
        /**
         * inventoryAddpubIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryAddpubIdPatch(params: {  id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryAddpubIdPatch(params, options)(fetch, basePath);
        },
        /**
         * inventoryBasePublishersStatisticsDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryBasePublishersStatisticsDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryBasePublishersStatisticsDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryBasePublishersStatisticsGet
         * @param token the security token, get it from login route (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param kind  (def)
         * @param status  (def)
         * @param p  page number (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param supplier  search the supplier field (def)
         * @param c  count per page (def)
         * @param q  parameter for search (def)
         * @param name  search the name field (def)
         * @param domain  search the domain field (def)
         */
        inventoryBasePublishersStatisticsGet(params: {  token?: string; to?: string; kind?: string; status?: string; p?: string; from?: string; supplier?: string; c?: string; q?: string; name?: string; domain?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryBasePublishersStatisticsGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryCreatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryCreatePost(params: {  token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryCreatePost(params, options)(fetch, basePath);
        },
        /**
         * inventoryDuplicatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryDuplicatePost(params: {  token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryDuplicatePost(params, options)(fetch, basePath);
        },
        /**
         * inventoryIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryIdPut(params: {  id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryIdPut(params, options)(fetch, basePath);
        },
        /**
         * inventoryInventoryIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryInventoryIdPatch(params: {  id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryInventoryIdPatch(params, options)(fetch, basePath);
        },
        /**
         * inventoryInventoryListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryInventoryListDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryInventoryListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryInventoryListGet
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param status  (def)
         * @param sort  (def)
         * @param label  search the label field (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        inventoryInventoryListGet(params: {  token?: string; c?: string; status?: string; sort?: string; label?: string; p?: string; q?: string; from?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryInventoryListGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryPublisherListDefinitionGet(params: {  token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListGet
         * @param token the security token, get it from login route (def)
         * @param p  page number (def)
         * @param sort  (def)
         * @param kind  (def)
         * @param status  (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param name  search the name field (def)
         * @param domain  search the domain field (def)
         * @param supplier  search the supplier field (def)
         * @param c  count per page (def)
         */
        inventoryPublisherListGet(params: {  token?: string; p?: string; sort?: string; kind?: string; status?: string; q?: string; from?: string; to?: string; name?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListSingleIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        inventoryPublisherListSingleIdDefinitionGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListSingleIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListSingleIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param domain  search the domain field (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param kind  (def)
         * @param status  (def)
         * @param p  page number (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param c  count per page (def)
         * @param name  search the name field (def)
         * @param q  parameter for search (def)
         * @param supplier  search the supplier field (def)
         */
        inventoryPublisherListSingleIdGet(params: {  id: string; token?: string; domain?: string; from?: string; kind?: string; status?: string; p?: string; to?: string; sort?: string; c?: string; name?: string; q?: string; supplier?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListSingleIdGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryRemovepubIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryRemovepubIdPatch(params: {  id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryRemovepubIdPatch(params, options)(fetch, basePath);
        },
        /**
         * uploadModuleModulePost
         * @param module  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadModuleModulePost(params: {  module: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadModuleModulePost(params, options)(fetch, basePath);
        },
        /**
         * uploadVideoIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadVideoIdGet(params: {  id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadVideoIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationApi - fetch parameter creator
 */
export const LocationApiFetchParamCreator = {
    /**
     * @func
     * locationCitiesProvincesIdGet
     * @param provincesId  param
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "provincesId" is set
        if (params["provincesId"] == null) {
            throw new Error("Missing required parameter provincesId when calling locationCitiesProvincesIdGet");
        }
        const baseUrl = `/location/cities/{provinces_id}`
            .replace(`{${"provinces_id"}}`, `${ params["provincesId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationProvincesCountryIdGet
     * @param countryId  param
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryId" is set
        if (params["countryId"] == null) {
            throw new Error("Missing required parameter countryId when calling locationProvincesCountryIdGet");
        }
        const baseUrl = `/location/provinces/{country_id}`
            .replace(`{${"country_id"}}`, `${ params["countryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: { provincesId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCities> {
        const fetchArgs = LocationApiFetchParamCreator.locationCitiesProvincesIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCountries> {
        const fetchArgs = LocationApiFetchParamCreator.locationCountriesGet(options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: { countryId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationProvinces> {
        const fetchArgs = LocationApiFetchParamCreator.locationProvincesCountryIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * locationCitiesProvincesIdGet
     * @param provincesId  (def)
     */
    locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
        return LocationApiFp.locationCitiesProvincesIdGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}) {
        return LocationApiFp.locationCountriesGet(options)(this.fetch, this.basePath);
    }
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
        return LocationApiFp.locationProvincesCountryIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * locationCitiesProvincesIdGet
         * @param provincesId  (def)
         */
        locationCitiesProvincesIdGet(params: {  provincesId: string; }, options: any = {}) {
            return LocationApiFp.locationCitiesProvincesIdGet(params, options)(fetch, basePath);
        },
        /**
         * locationCountriesGet
         */
        locationCountriesGet(options: any = {}) {
            return LocationApiFp.locationCountriesGet(options)(fetch, basePath);
        },
        /**
         * locationProvincesCountryIdGet
         * @param countryId  (def)
         */
        locationProvincesCountryIdGet(params: {  countryId: string; }, options: any = {}) {
            return LocationApiFp.locationProvincesCountryIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * @func
     * userAvatarPut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userAvatarPut(params: {  token?: string; payloadData?: UserAvatarPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/avatar`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyPost
     * @param payloadData  param
     */
    userEmailVerifyPost(params: {  payloadData?: UserVerifyEmailCodePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyResendPost
     * @param payloadData  param
     */
    userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify/resend`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyTokenGet
     * @param token  param
     */
    userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/email/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLoginPost
     * @param payloadData  param
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route param
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout/closeother`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutGet
     * @param token the security token, get it from login route param
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userMailCheckPost
     * @param payloadData  param
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/mail/check`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangeTokenPut
     * @param token  param
     * @param payloadData  param
     */
    userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordForgetPost
     * @param payloadData  param
     */
    userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/forget`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyPost
     * @param payloadData  param
     */
    userPasswordVerifyPost(params: {  payloadData?: UserForgetCodePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/verify/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyTokenGet
     * @param token  param
     */
    userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPingGet
     * @param token the security token, get it from login route param
     */
    userPingGet(params: {  token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/ping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userRegisterPost
     * @param payloadData  param
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userStorePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userStorePost(params: {  token?: string; payloadData?: UserStorePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/store`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userUpdatePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/update`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * userAvatarPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAvatarPut(params: { token?: string; payloadData?: UserAvatarPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userAvatarPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyPost
     * @param payloadData  (def)
     */
    userEmailVerifyPost(params: { payloadData?: UserVerifyEmailCodePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyResendPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: { payloadData?: UserLoginPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLoginPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutCloseotherGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userLogoutGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserCheckMailResponse> {
        const fetchArgs = UserApiFetchParamCreator.userMailCheckPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangeTokenPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: { payloadData?: UserForgetPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordForgetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordVerifyPost
     * @param payloadData  (def)
     */
    userPasswordVerifyPost(params: { payloadData?: UserForgetCodePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: { token?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userPingGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userRegisterPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userStorePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStorePost(params: { token?: string; payloadData?: UserStorePayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        const fetchArgs = UserApiFetchParamCreator.userStorePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: { token?: string; payloadData?: UserUserPayload;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        const fetchArgs = UserApiFetchParamCreator.userUpdatePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                  return response.json()
                  .then(res => {
                    res.status = response.status;
                    throw res;
                  })
                  .catch((err) => {
                    err.status = response.status;
                    throw err;
                  });
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * userAvatarPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAvatarPut(params: {  token?: string; payloadData?: UserAvatarPayload; }, options: any = {}) {
        return UserApiFp.userAvatarPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyPost
     * @param payloadData  (def)
     */
    userEmailVerifyPost(params: {  payloadData?: UserVerifyEmailCodePayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyResendPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userEmailVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
        return UserApiFp.userLoginPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutCloseotherGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
        return UserApiFp.userMailCheckPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
        return UserApiFp.userPasswordChangePut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
        return UserApiFp.userPasswordChangeTokenPut(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}) {
        return UserApiFp.userPasswordForgetPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordVerifyPost
     * @param payloadData  (def)
     */
    userPasswordVerifyPost(params: {  payloadData?: UserForgetCodePayload; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: {  token?: string; }, options: any = {}) {
        return UserApiFp.userPingGet(params, options)(this.fetch, this.basePath);
    }
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
        return UserApiFp.userRegisterPost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userStorePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStorePost(params: {  token?: string; payloadData?: UserStorePayload; }, options: any = {}) {
        return UserApiFp.userStorePost(params, options)(this.fetch, this.basePath);
    }
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
        return UserApiFp.userUpdatePut(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * userAvatarPut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userAvatarPut(params: {  token?: string; payloadData?: UserAvatarPayload; }, options: any = {}) {
            return UserApiFp.userAvatarPut(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyPost
         * @param payloadData  (def)
         */
        userEmailVerifyPost(params: {  payloadData?: UserVerifyEmailCodePayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyResendPost
         * @param payloadData  (def)
         */
        userEmailVerifyResendPost(params: {  payloadData?: UserVerifyResendPayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyResendPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyTokenGet
         * @param token  (def)
         */
        userEmailVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userEmailVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userLoginPost
         * @param payloadData  (def)
         */
        userLoginPost(params: {  payloadData?: UserLoginPayload; }, options: any = {}) {
            return UserApiFp.userLoginPost(params, options)(fetch, basePath);
        },
        /**
         * userLogoutCloseotherGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutCloseotherGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutCloseotherGet(params, options)(fetch, basePath);
        },
        /**
         * userLogoutGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutGet(params, options)(fetch, basePath);
        },
        /**
         * userMailCheckPost
         * @param payloadData  (def)
         */
        userMailCheckPost(params: {  payloadData?: UserCheckMailPayload; }, options: any = {}) {
            return UserApiFp.userMailCheckPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userPasswordChangePut(params: {  token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
            return UserApiFp.userPasswordChangePut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangeTokenPut
         * @param token  (def)
         * @param payloadData  (def)
         */
        userPasswordChangeTokenPut(params: {  token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
            return UserApiFp.userPasswordChangeTokenPut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordForgetPost
         * @param payloadData  (def)
         */
        userPasswordForgetPost(params: {  payloadData?: UserForgetPayload; }, options: any = {}) {
            return UserApiFp.userPasswordForgetPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyPost
         * @param payloadData  (def)
         */
        userPasswordVerifyPost(params: {  payloadData?: UserForgetCodePayload; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyTokenGet
         * @param token  (def)
         */
        userPasswordVerifyTokenGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userPingGet
         * @param token the security token, get it from login route (def)
         */
        userPingGet(params: {  token?: string; }, options: any = {}) {
            return UserApiFp.userPingGet(params, options)(fetch, basePath);
        },
        /**
         * userRegisterPost
         * @param payloadData  (def)
         */
        userRegisterPost(params: {  payloadData?: UserRegisterPayload; }, options: any = {}) {
            return UserApiFp.userRegisterPost(params, options)(fetch, basePath);
        },
        /**
         * userStorePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userStorePost(params: {  token?: string; payloadData?: UserStorePayload; }, options: any = {}) {
            return UserApiFp.userStorePost(params, options)(fetch, basePath);
        },
        /**
         * userUpdatePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userUpdatePut(params: {  token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
            return UserApiFp.userUpdatePut(params, options)(fetch, basePath);
        },
    };
};

