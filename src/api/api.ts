/**
 * The clickyab.com/crab API
 * The crab api, auto generated
 *
 * OpenAPI spec version: \"0.0.1-pre-alpha\"
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import AAA from "./../services/AAA/index";
import * as querystring from "querystring";
import * as url from "url";
import * as assign from "core-js/library/fn/object/assign";
import permMap from "./permMap";
import "whatwg-fetch";

interface Dictionary<T> {
    [index: string]: T;
}

export interface FetchAPI {
    (url: string, init?: any): Promise<any>;
}

export const BASE_PATH = "http://staging.crab.clickyab.ae/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    configuration: object;

    constructor(fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH, configuration: object = {}) {
        this.basePath = basePath;
        this.fetch = fetchFn;
        this.configuration = configuration;
    }
}

const removeEmpty = (obj) => {
    const objectInstance = JSON.parse(JSON.stringify(obj)); // Clone source oect.

    Object.keys(objectInstance).forEach(key => {
        if (objectInstance[key] && typeof objectInstance[key] === "object")
            objectInstance[key] = removeEmpty(objectInstance[key]);  // Recurse.
        else if (objectInstance[key] === undefined || objectInstance[key] === null) {
            delete objectInstance[key]; // Delete undefined and null.
        }
        else
            objectInstance[key] = objectInstance[key];  // Copy value.
    });

    return objectInstance; // Return new object.
};

export interface AaaAccountType {
}

export interface AaaUserList {
    "_actions"?: string;
    "account_type"?: string;
    "avatar"?: AaaUserListAvatar;
    "balance"?: number;
    "cellphone"?: AaaUserListAvatar;
    "created_at"?: string;
    "email"?: string;
    "full_name"?: string;
    "id"?: number;
    "land_line"?: AaaUserListAvatar;
    "ssn"?: AaaUserListAvatar;
    "status"?: string;
}

export interface AaaUserListAvatar {
    "String"?: string;
    "Valid"?: boolean;
}

export interface AaaUserSearchResult {
    "email"?: string;
    "id"?: number;
}

export interface AaaUserValidStatus {
}

export interface ControllerErrorResponseSimple {
    "error"?: NotAuthorizedError;
}

export interface ControllerNormalResponse {
}

export interface ControllersAddGatewayPayload {
    "name"?: string;
    "status"?: string;
}

export interface ControllersAddInventoryPayload {
    "pub_ids"?: Array<number>;
}

export interface ControllersAssignInventoryPayload {
    "id"?: number;
    "state"?: string;
}

export interface ControllersAttributesPayload {
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "device"?: Array<string>;
    "iab"?: Array<string>;
    "isp"?: Array<string>;
    "manufacturer"?: Array<string>;
    "os"?: Array<string>;
    "region"?: Array<string>;
}

export interface ControllersAttributesResult {
    "archived_at"?: string;
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "created_at"?: string;
    "daily_budget"?: number;
    "device"?: Array<string>;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "iab"?: Array<string>;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "isp"?: Array<string>;
    "kind"?: string;
    "manufacturer"?: Array<string>;
    "max_bid"?: number;
    "os"?: Array<string>;
    "progress"?: string;
    "region"?: Array<string>;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersAttributesResultInventoryType {
    "InventoryState"?: string;
    "Valid"?: boolean;
}

export interface ControllersBaseResult {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "schedule"?: ControllersBaseResultSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersBaseResultSchedule {
    "campaign_id"?: number;
    "h00"?: AaaUserListAvatar;
    "h01"?: AaaUserListAvatar;
    "h02"?: AaaUserListAvatar;
    "h03"?: AaaUserListAvatar;
    "h04"?: AaaUserListAvatar;
    "h05"?: AaaUserListAvatar;
    "h06"?: AaaUserListAvatar;
    "h07"?: AaaUserListAvatar;
    "h08"?: AaaUserListAvatar;
    "h09"?: AaaUserListAvatar;
    "h10"?: AaaUserListAvatar;
    "h11"?: AaaUserListAvatar;
    "h12"?: AaaUserListAvatar;
    "h13"?: AaaUserListAvatar;
    "h14"?: AaaUserListAvatar;
    "h15"?: AaaUserListAvatar;
    "h16"?: AaaUserListAvatar;
    "h17"?: AaaUserListAvatar;
    "h18"?: AaaUserListAvatar;
    "h19"?: AaaUserListAvatar;
    "h20"?: AaaUserListAvatar;
    "h21"?: AaaUserListAvatar;
    "h22"?: AaaUserListAvatar;
    "h23"?: AaaUserListAvatar;
    "id"?: number;
    "updated_at"?: string;
}

export interface ControllersBrowserResponse extends Array<ControllersBrowserResponseInner> {
}

export interface ControllersBrowserResponseInner {
    "created_at"?: string;
    "deleted_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersBudgetPayload {
    "daily_budget"?: number;
    "exchange"?: string;
    "max_bid"?: number;
    "receivers"?: Array<number>;
    "strategy"?: string;
    "total_budget"?: number;
}

export interface ControllersCampaignBase {
    "end_at"?: string;
    "schedule"?: ControllersCampaignBaseSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface ControllersCampaignBaseSchedule {
    "h00"?: string;
    "h01"?: string;
    "h02"?: string;
    "h03"?: string;
    "h04"?: string;
    "h05"?: string;
    "h06"?: string;
    "h07"?: string;
    "h08"?: string;
    "h09"?: string;
    "h10"?: string;
    "h11"?: string;
    "h12"?: string;
    "h13"?: string;
    "h14"?: string;
    "h15"?: string;
    "h16"?: string;
    "h17"?: string;
    "h18"?: string;
    "h19"?: string;
    "h20"?: string;
    "h21"?: string;
    "h22"?: string;
    "h23"?: string;
}

export interface ControllersCampaignGetResponse {
    "archived_at"?: string;
    "attributes"?: ControllersCampaignGetResponseAttributes;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory"?: ControllersCampaignGetResponseInventory;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "receivers"?: Array<ControllersCampaignGetResponseReceivers>;
    "schedule"?: ControllersCampaignGetResponseSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersCampaignGetResponseAttributes {
    "browser"?: Array<string>;
    "cellular"?: Array<string>;
    "device"?: Array<string>;
    "iab"?: Array<string>;
    "isp"?: Array<string>;
    "manufacturer"?: Array<string>;
    "os"?: Array<string>;
    "region"?: Array<string>;
}

export interface ControllersCampaignGetResponseInventory {
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "publisher_count"?: number;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersCampaignGetResponseReceivers {
    "email"?: string;
    "id"?: number;
}

export interface ControllersCampaignGetResponseSchedule {
    "h00"?: AaaUserListAvatar;
    "h01"?: AaaUserListAvatar;
    "h02"?: AaaUserListAvatar;
    "h03"?: AaaUserListAvatar;
    "h04"?: AaaUserListAvatar;
    "h05"?: AaaUserListAvatar;
    "h06"?: AaaUserListAvatar;
    "h07"?: AaaUserListAvatar;
    "h08"?: AaaUserListAvatar;
    "h09"?: AaaUserListAvatar;
    "h10"?: AaaUserListAvatar;
    "h11"?: AaaUserListAvatar;
    "h12"?: AaaUserListAvatar;
    "h13"?: AaaUserListAvatar;
    "h14"?: AaaUserListAvatar;
    "h15"?: AaaUserListAvatar;
    "h16"?: AaaUserListAvatar;
    "h17"?: AaaUserListAvatar;
    "h18"?: AaaUserListAvatar;
    "h19"?: AaaUserListAvatar;
    "h20"?: AaaUserListAvatar;
    "h21"?: AaaUserListAvatar;
    "h22"?: AaaUserListAvatar;
    "h23"?: AaaUserListAvatar;
}

export interface ControllersCatResponse extends Array<ControllersCatResponseInner> {
}

export interface ControllersCatResponseInner {
    "deleted_at"?: ControllersCatResponseInnerDeletedAt;
    "description"?: string;
    "name"?: string;
}

export interface ControllersCatResponseInnerDeletedAt {
    "Time"?: string;
    "Valid"?: boolean;
}

export interface ControllersChangeCampaignStatus {
    "status"?: string;
}

export interface ControllersChangeCashResult {
    "amount"?: number;
    "target_user_id"?: number;
}

export interface ControllersChangeCashStatus {
    "amount"?: number;
    "description"?: string;
    "reason"?: string;
    "user_id"?: number;
}

export interface ControllersChangeLabelPayload {
    "label"?: string;
}

export interface ControllersChangeStatus {
    "status"?: string;
}

export interface ControllersChangeStatusPayload {
    "status"?: string;
}

export interface ControllersChangeStatusResult {
    "creatives_status"?: Array<ControllersChangeStatusResultCreativesStatus>;
}

export interface ControllersChangeStatusResultCreativesStatus {
    "creative_id"?: number;
    "reject_reason_id"?: number;
    "status"?: string;
}

export interface ControllersCreateCampaignPayload {
    "end_at"?: string;
    "kind"?: string;
    "schedule"?: ControllersCampaignBaseSchedule;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "tld"?: string;
}

export interface ControllersCreateDomainPayload {
    "attributes"?: { [key: string]: string; };
    "description"?: string;
    "name"?: string;
    "status"?: string;
}

export interface ControllersCreateDomainResult {
    "domain_id"?: number;
    "name"?: string;
    "status"?: string;
}

export interface ControllersCreateInventoryPayload {
    "label"?: string;
    "pub_ids"?: Array<number>;
}

export interface ControllersCreateNativePayload {
    "assets"?: ControllersCreateNativePayloadAssets;
    "attributes"?: { [key: string]: string; };
    "campaign_id"?: number;
    "max_bid"?: number;
    "name"?: string;
    "url"?: string;
}

export interface ControllersCreateNativePayloadAssets {
    "cta"?: Array<ControllersNativeAssetPayloadCta>;
    "description"?: Array<ControllersNativeAssetPayloadCta>;
    "downloads"?: Array<ControllersNativeAssetPayloadDownloads>;
    "icon"?: Array<ControllersNativeAssetPayloadCta>;
    "images"?: Array<ControllersNativeAssetPayloadCta>;
    "logo"?: Array<ControllersNativeAssetPayloadCta>;
    "phone"?: Array<ControllersNativeAssetPayloadCta>;
    "price"?: Array<ControllersNativeAssetPayloadPrice>;
    "rating"?: Array<ControllersNativeAssetPayloadPrice>;
    "sale_price"?: Array<ControllersNativeAssetPayloadPrice>;
    "title"?: Array<ControllersNativeAssetPayloadCta>;
    "video"?: Array<ControllersNativeAssetPayloadCta>;
}

export interface ControllersCreativeStatusChangeResult {
    "campaign"?: number;
    "effected_creatives"?: number;
}

export interface ControllersDuplicateInventoryPayload {
    "id"?: number;
}

export interface ControllersEditGatewayPayload {
    "name"?: string;
    "status"?: string;
}

export interface ControllersEditNativePayload {
    "assets"?: ControllersCreateNativePayloadAssets;
    "attributes"?: { [key: string]: string; };
    "max_bid"?: number;
    "name"?: string;
    "url"?: string;
}

export interface ControllersFinalizeResult {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersGetCreativeResp extends Array<string> {
}

export interface ControllersGetGateResp extends Array<ControllersGetGateRespInner> {
}

export interface ControllersGetGateRespInner {
    "created_at"?: string;
    "id"?: number;
    "is_default"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersGetVideoResponse {
    "ready"?: string;
}

export interface ControllersGraphBillinggraphreportData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphBillinggraphreportResponse {
    "data"?: Array<ControllersGraphBillinggraphreportResponseData>;
    "format"?: string;
    "from"?: string;
    "to"?: string;
    "type"?: string;
}

export interface ControllersGraphBillinggraphreportResponseData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartallData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartallResponse {
    "data"?: Array<ControllersGraphBillinggraphreportResponseData>;
    "format"?: string;
    "from"?: string;
    "to"?: string;
    "type"?: string;
}

export interface ControllersGraphChartdailyData {
    "avg"?: number;
    "data"?: Array<number>;
    "hidden"?: boolean;
    "max"?: number;
    "min"?: number;
    "name"?: string;
    "order"?: number;
    "sum"?: number;
    "title"?: string;
    "type"?: string;
}

export interface ControllersGraphChartdailyResponse {
    "data"?: Array<ControllersGraphBillinggraphreportResponseData>;
    "format"?: string;
    "from"?: string;
    "to"?: string;
    "type"?: string;
}

export interface ControllersInitPaymentPayload {
    "charge_amount"?: number;
    "gate_way"?: number;
}

export interface ControllersIspResponse extends Array<ControllersIspResponseInner> {
}

export interface ControllersIspResponseInner {
    "created_at"?: string;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersListBasePublisherStatisticsDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListBasePublisherStatisticsDefResponseColumns {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface ControllersListBasePublisherStatisticsResponse {
    "data"?: Array<ControllersListBasePublisherStatisticsResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListBasePublisherStatisticsResponseData {
    "avg_imp"?: number;
    "count"?: number;
    "domain"?: string;
    "exchange_count"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
}

export interface ControllersListBillingreportDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListBillingreportResponse {
    "data"?: Array<ControllersListBillingreportResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListBillingreportResponseData {
    "_actions"?: string;
    "amount"?: number;
    "balance"?: number;
    "created_at"?: string;
    "email"?: string;
    "first_name"?: string;
    "id"?: number;
    "last_name"?: string;
    "pay_model"?: string;
    "user_id"?: number;
}

export interface ControllersListCampaigndailyDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListCampaigndailyResponse {
    "data"?: Array<ControllersListCampaigndailyResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCampaigndailyResponseData {
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "date"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface ControllersListCampaignsDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListCampaignsResponse {
    "data"?: Array<ControllersListCampaignsResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCampaignsResponseData {
    "_actions"?: string;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "created_at"?: string;
    "creative"?: number;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "today_click"?: number;
    "today_ctr"?: number;
    "today_imp"?: number;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_click"?: number;
    "total_imp"?: number;
    "total_spend"?: number;
}

export interface ControllersListCreativecampaignreportDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListCreativecampaignreportResponse {
    "data"?: Array<ControllersListCreativecampaignreportResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListCreativecampaignreportResponseData {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "created_at"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "name"?: string;
    "spend"?: number;
    "status"?: string;
    "type"?: string;
}

export interface ControllersListInventoryDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListInventoryResponse {
    "data"?: Array<ControllersListInventoryResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListInventoryResponseData {
    "_actions"?: string;
    "attached"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersListInvpublisherDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListInvpublisherResponse {
    "data"?: Array<ControllersListInvpublisherResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListInvpublisherResponseData {
    "_actions"?: string;
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface ControllersListPublisherDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListPublisherResponse {
    "data"?: Array<ControllersListInvpublisherResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListPublisherdetailsDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface ControllersListPublisherdetailsResponse {
    "data"?: Array<ControllersListPublisherdetailsResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface ControllersListPublisherdetailsResponseData {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "domain"?: AaaUserListAvatar;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface ControllersManufacturers extends Array<ControllersManufacturersInner> {
}

export interface ControllersManufacturersInner {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface ControllersNativeAssetPayload {
    "cta"?: Array<ControllersNativeAssetPayloadCta>;
    "description"?: Array<ControllersNativeAssetPayloadCta>;
    "downloads"?: Array<ControllersNativeAssetPayloadDownloads>;
    "icon"?: Array<ControllersNativeAssetPayloadCta>;
    "images"?: Array<ControllersNativeAssetPayloadCta>;
    "logo"?: Array<ControllersNativeAssetPayloadCta>;
    "phone"?: Array<ControllersNativeAssetPayloadCta>;
    "price"?: Array<ControllersNativeAssetPayloadPrice>;
    "rating"?: Array<ControllersNativeAssetPayloadPrice>;
    "sale_price"?: Array<ControllersNativeAssetPayloadPrice>;
    "title"?: Array<ControllersNativeAssetPayloadCta>;
    "video"?: Array<ControllersNativeAssetPayloadCta>;
}

export interface ControllersNativeAssetPayloadCta {
    "label"?: string;
    "val"?: string;
}

export interface ControllersNativeAssetPayloadDownloads {
    "label"?: string;
    "val"?: number;
}

export interface ControllersNativeAssetPayloadPrice {
    "label"?: string;
    "val"?: number;
}

export interface ControllersNotifyUserTypes {
}

export interface ControllersOsResponse extends Array<ControllersManufacturersInner> {
}

export interface ControllersPlatformResponse extends Array<ControllersManufacturersInner> {
}

export interface ControllersRegisterBankSnapPayload {
    "amount"?: number;
    "trace_number"?: number;
}

export interface ControllersRejectReasons extends Array<ControllersRejectReasonsInner> {
}

export interface ControllersRejectReasonsInner {
    "created_at"?: string;
    "id"?: number;
    "reason"?: string;
    "status"?: string;
    "updated_at"?: ControllersCatResponseInnerDeletedAt;
}

export interface ControllersRemoveInventoryPayload {
    "pub_ids"?: Array<number>;
}

export interface ControllersUpdateResult {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "schedule"?: ControllersBaseResultSchedule;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface ControllersUploadResponse {
    "src"?: string;
}

export interface LocationCities extends Array<LocationCitiesInner> {
}

export interface LocationCitiesInner {
    "id"?: number;
    "name"?: string;
    "province"?: string;
}

export interface LocationCity {
    "id"?: number;
    "name"?: string;
    "province"?: string;
}

export interface LocationCountries extends Array<LocationCountriesInner> {
}

export interface LocationCountriesInner {
    "id"?: number;
    "name"?: string;
}

export interface LocationCountry {
    "id"?: number;
    "name"?: string;
}

export interface LocationProvince {
    "code"?: string;
    "country_id"?: number;
    "fa_name"?: string;
    "name"?: string;
}

export interface LocationProvinces extends Array<LocationProvincesInner> {
}

export interface LocationProvincesInner {
    "code"?: string;
    "country_id"?: number;
    "fa_name"?: string;
    "name"?: string;
}

export interface NotAuthorized {
    "error"?: NotAuthorizedError;
}

export interface NotAuthorizedError {
    "params"?: Array<string>;
    "text"?: string;
}

export interface OrmAssetStatus {
}

export interface OrmBankReasonState {
}

export interface OrmBankSnap {
    "amount"?: number;
    "checked_by"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "pay_amount"?: number;
    "status"?: string;
    "trace_number"?: number;
    "updated_at"?: string;
    "user_id"?: number;
    "vat"?: number;
}

export interface OrmBankSnapCheckStatus {
}

export interface OrmBilling {
    "amount"?: number;
    "balance"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "income_id"?: number;
    "pay_amount"?: number;
    "pay_model"?: string;
    "user_id"?: number;
    "vat"?: number;
}

export interface OrmBillingDataTable {
    "_actions"?: string;
    "amount"?: number;
    "balance"?: number;
    "created_at"?: string;
    "email"?: string;
    "first_name"?: string;
    "id"?: number;
    "last_name"?: string;
    "pay_model"?: string;
    "user_id"?: number;
}

export interface OrmBrowser {
    "created_at"?: string;
    "deleted_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmCampaign {
    "archived_at"?: string;
    "created_at"?: string;
    "daily_budget"?: number;
    "domain_id"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "inventory_id"?: number;
    "inventory_type"?: ControllersAttributesResultInventoryType;
    "kind"?: string;
    "max_bid"?: number;
    "progress"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "tld"?: string;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_spend"?: number;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmCampaignDaily {
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "date"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface OrmCampaignDetails {
    "_actions"?: string;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "created_at"?: string;
    "creative"?: number;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "end_at"?: string;
    "exchange"?: string;
    "id"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "start_at"?: string;
    "status"?: string;
    "strategy"?: string;
    "title"?: string;
    "today_click"?: number;
    "today_ctr"?: number;
    "today_imp"?: number;
    "today_spend"?: number;
    "total_budget"?: number;
    "total_click"?: number;
    "total_imp"?: number;
    "total_spend"?: number;
}

export interface OrmCampaignKind {
}

export interface OrmCampaignProgress {
    "avg_cpc"?: number;
    "click"?: number;
    "ctr"?: number;
    "daily_budget"?: number;
    "end_at"?: string;
    "imp"?: number;
    "kind"?: string;
    "max_bid"?: number;
    "owner_email"?: string;
    "start_at"?: string;
    "status"?: string;
    "title"?: string;
    "total_budget"?: number;
    "total_spend"?: number;
}

export interface OrmCategory {
    "deleted_at"?: ControllersCatResponseInnerDeletedAt;
    "description"?: string;
    "name"?: string;
}

export interface OrmChangeStatusReq {
    "creative_id"?: number;
    "reject_reason_id"?: number;
    "status"?: string;
}

export interface OrmCreative {
    "archived_at"?: string;
    "attributes"?: { [key: string]: string; };
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "name"?: string;
    "reject_reason_id"?: number;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
    "user_id"?: number;
}

export interface OrmCreativeDataTable {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "created_at"?: string;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "name"?: string;
    "spend"?: number;
    "status"?: string;
    "type"?: string;
}

export interface OrmCreativeRejectReasons {
    "created_at"?: string;
    "id"?: number;
    "reason"?: string;
    "status"?: string;
    "updated_at"?: ControllersCatResponseInnerDeletedAt;
}

export interface OrmCreativeSaveResult {
    "assets"?: { [key: string]: Array<string>; };
    "creative"?: OrmCreativeSaveResultCreative;
}

export interface OrmCreativeSaveResultCreative {
    "archived_at"?: string;
    "attributes"?: { [key: string]: string; };
    "campaign_id"?: number;
    "created_at"?: string;
    "id"?: number;
    "max_bid"?: number;
    "name"?: string;
    "reject_reason_id"?: number;
    "status"?: string;
    "type"?: string;
    "updated_at"?: string;
    "url"?: string;
    "user_id"?: number;
}

export interface OrmCreativeStatusType {
}

export interface OrmCreativeTypes {
}

export interface OrmDefaultType {
}

export interface OrmDomain {
    "attributes"?: { [key: string]: string; };
    "created_at"?: string;
    "description"?: AaaUserListAvatar;
    "id"?: number;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmDomainStatus {
}

export interface OrmExchangeType {
}

export interface OrmGateway {
    "created_at"?: string;
    "id"?: number;
    "is_default"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmGatewayStatus {
}

export interface OrmISP {
    "created_at"?: string;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmISPKind {
}

export interface OrmInventory {
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmInventoryDataTable {
    "_actions"?: string;
    "attached"?: number;
    "created_at"?: string;
    "domain_id"?: number;
    "id"?: number;
    "label"?: string;
    "status"?: string;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmInventoryState {
}

export interface OrmInventoryStatus {
}

export interface OrmManufacturer {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmNativeFloat {
    "label"?: string;
    "val"?: number;
}

export interface OrmNativeInt {
    "label"?: string;
    "val"?: number;
}

export interface OrmNativeString {
    "label"?: string;
    "val"?: string;
}

export interface OrmNullBankReason {
    "BankReason"?: string;
    "Valid"?: boolean;
}

export interface OrmNullInventoryState {
    "InventoryState"?: string;
    "Valid"?: boolean;
}

export interface OrmOS {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmOnlinePayment {
    "amount"?: number;
    "attr"?: { [key: string]: string; };
    "bank_status"?: number;
    "cid"?: AaaUserListAvatar;
    "created_at"?: string;
    "domain_id"?: number;
    "error_reason"?: OrmOnlinePaymentErrorReason;
    "gateway_id"?: number;
    "id"?: number;
    "ref_num"?: AaaUserListAvatar;
    "res_num"?: string;
    "status"?: string;
    "trace_number"?: AaaUserListAvatar;
    "updated_at"?: string;
    "user_id"?: number;
}

export interface OrmOnlinePaymentErrorReason {
    "BankReason"?: string;
    "Valid"?: boolean;
}

export interface OrmOnlinePaymentStatus {
}

export interface OrmPayModels {
}

export interface OrmPlatform {
    "created_at"?: string;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface OrmProgress {
}

export interface OrmPublisher {
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface OrmPublisherDataTable {
    "_actions"?: string;
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface OrmPublisherDetails {
    "_actions"?: string;
    "click"?: number;
    "conversion"?: number;
    "conversion_rate"?: number;
    "cpa"?: number;
    "domain"?: AaaUserListAvatar;
    "ecpc"?: number;
    "ecpm"?: number;
    "ectr"?: number;
    "impression"?: number;
    "spend"?: number;
}

export interface OrmPublisherType {
}

export interface OrmPublishersBaseStatistics {
    "avg_imp"?: number;
    "count"?: number;
    "domain"?: string;
    "exchange_count"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
}

export interface OrmReceiver {
    "email"?: string;
    "id"?: number;
}

export interface OrmRejectReasonStatusTypes {
}

export interface OrmScheduleSheet {
    "h00"?: AaaUserListAvatar;
    "h01"?: AaaUserListAvatar;
    "h02"?: AaaUserListAvatar;
    "h03"?: AaaUserListAvatar;
    "h04"?: AaaUserListAvatar;
    "h05"?: AaaUserListAvatar;
    "h06"?: AaaUserListAvatar;
    "h07"?: AaaUserListAvatar;
    "h08"?: AaaUserListAvatar;
    "h09"?: AaaUserListAvatar;
    "h10"?: AaaUserListAvatar;
    "h11"?: AaaUserListAvatar;
    "h12"?: AaaUserListAvatar;
    "h13"?: AaaUserListAvatar;
    "h14"?: AaaUserListAvatar;
    "h15"?: AaaUserListAvatar;
    "h16"?: AaaUserListAvatar;
    "h17"?: AaaUserListAvatar;
    "h18"?: AaaUserListAvatar;
    "h19"?: AaaUserListAvatar;
    "h20"?: AaaUserListAvatar;
    "h21"?: AaaUserListAvatar;
    "h22"?: AaaUserListAvatar;
    "h23"?: AaaUserListAvatar;
}

export interface OrmSinglePublisherDataTable {
    "_actions"?: string;
    "categories"?: Array<string>;
    "created_at"?: string;
    "deleted_at"?: string;
    "domain"?: string;
    "id"?: number;
    "kind"?: string;
    "name"?: string;
    "status"?: string;
    "supplier"?: string;
    "updated_at"?: string;
}

export interface OrmStatus {
}

export interface OrmStrategy {
}

export interface PaymentInitPaymentResp {
    "bank_url"?: string;
    "method"?: string;
    "params"?: { [key: string]: string; };
}

export interface PermissionColumn {
    "data"?: string;
    "filter"?: boolean;
    "filter_valid_map"?: { [key: string]: Array<string>; };
    "name"?: string;
    "searchable"?: boolean;
    "sortable"?: boolean;
    "title"?: string;
    "type"?: string;
    "visible"?: boolean;
}

export interface TransT9Base {
    "params"?: Array<string>;
    "text"?: string;
}

export interface UserAddUserToWhitelabelPayload {
    "account_type"?: string;
    "corporation_info"?: UserAddUserToWhitelabelPayloadCorporationInfo;
    "email"?: string;
    "first_name"?: string;
    "last_name"?: string;
    "mobile"?: string;
    "notify_user"?: boolean;
    "password"?: string;
    "role_id"?: number;
}

export interface UserAddUserToWhitelabelPayloadCorporationInfo {
    "economic_code"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
}

export interface UserAvatarPayload {
    "avatar"?: string;
}

export interface UserCallBackPayload {
    "new_password"?: string;
}

export interface UserChangePass {
    "password"?: string;
}

export interface UserChangePassword {
    "current_password"?: string;
    "new_password"?: string;
}

export interface UserChangeUserStatus {
    "status"?: string;
}

export interface UserChangeUserStatusResult {
    "new_status"?: string;
    "user_id"?: number;
}

export interface UserCheckMailPayload {
    "email"?: string;
}

export interface UserCheckMailResponse {
    "current_domain"?: boolean;
    "domains"?: Array<UserCheckMailResponseDomains>;
}

export interface UserCheckMailResponseDomains {
    "attributes"?: { [key: string]: string; };
    "created_at"?: string;
    "description"?: AaaUserListAvatar;
    "id"?: number;
    "name"?: string;
    "status"?: string;
    "updated_at"?: string;
}

export interface UserEditAdminResp {
    "account"?: UserResponseLoginOKAccount;
    "managers"?: Array<string>;
}

export interface UserEditUserPayload {
    "address"?: string;
    "cell_phone"?: string;
    "city_id"?: number;
    "economic_code"?: string;
    "first_name"?: string;
    "gender"?: string;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "managers"?: Array<number>;
    "postal_code"?: string;
    "ssn"?: string;
}

export interface UserForgetCodePayload {
    "code"?: string;
    "email"?: string;
}

export interface UserForgetPayload {
    "email"?: string;
}

export interface UserListUsersListDefResponse {
    "checkable"?: boolean;
    "columns"?: Array<ControllersListBasePublisherStatisticsDefResponseColumns>;
    "datefilter"?: string;
    "hash"?: string;
    "multiselect"?: boolean;
    "searchkey"?: string;
}

export interface UserListUsersListResponse {
    "data"?: Array<UserListUsersListResponseData>;
    "hash"?: string;
    "page"?: number;
    "per_page"?: number;
    "total"?: number;
}

export interface UserListUsersListResponseData {
    "_actions"?: string;
    "account_type"?: string;
    "avatar"?: AaaUserListAvatar;
    "balance"?: number;
    "cellphone"?: AaaUserListAvatar;
    "created_at"?: string;
    "email"?: string;
    "full_name"?: string;
    "id"?: number;
    "land_line"?: AaaUserListAvatar;
    "ssn"?: AaaUserListAvatar;
    "status"?: string;
}

export interface UserLoginPayload {
    "email"?: string;
    "password"?: string;
}

export interface UserRegisterPayload {
    "email"?: string;
    "first_name"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "mobile"?: string;
    "password"?: string;
}

export interface UserResponseLoginOK {
    "account"?: UserResponseLoginOKAccount;
    "impersonator_token"?: string;
    "perms"?: Array<string>;
    "token"?: string;
}

export interface UserResponseLoginOKAccount {
    "address"?: string;
    "attributes"?: { [key: string]: string; };
    "avatar"?: string;
    "balance"?: number;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "perms"?: Array<string>;
    "postal_code"?: string;
    "province"?: string;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserSearchUserPayload {
    "email"?: string;
}

export interface UserStartImpersonatePayload {
    "user_id"?: number;
}

export interface UserStorePayload {
    "data"?: { [key: string]: string; };
}

export interface UserUserPayload {
    "address"?: string;
    "cell_phone"?: string;
    "city_id"?: number;
    "economic_code"?: string;
    "first_name"?: string;
    "gender"?: string;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "postal_code"?: string;
    "ssn"?: string;
}

export interface UserUserResponse {
    "address"?: string;
    "attributes"?: { [key: string]: string; };
    "avatar"?: string;
    "balance"?: number;
    "cellphone"?: string;
    "city_id"?: number;
    "city_name"?: string;
    "country_id"?: number;
    "country_name"?: string;
    "economic_code"?: string;
    "email"?: string;
    "first_name"?: string;
    "gender"?: string;
    "id"?: number;
    "land_line"?: string;
    "last_name"?: string;
    "legal_name"?: string;
    "legal_register"?: string;
    "perms"?: Array<string>;
    "postal_code"?: string;
    "province"?: string;
    "province_name"?: string;
    "ssn"?: string;
}

export interface UserUserSearchResp extends Array<ControllersCampaignGetResponseReceivers> {
}

export interface UserVerifyEmailCodePayload {
    "code"?: string;
    "email"?: string;
}

export interface UserVerifyResendPayload {
    "email"?: string;
}



/**
 * ControllersApi - fetch parameter creator
 */
export const ControllersApiFetchParamCreator = {
    /**
     * @func
     * adCampaignCreativeStatusIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adCampaignCreativeStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatus; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCampaignCreativeStatusIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/campaign-creative-status/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adCampaignIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    adCampaignIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCampaignIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/campaign/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adCampaignIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param p  page number param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param status  param
     * @param type  param
     * @param name  search the name field param
     */
    adCampaignIdGet(params: { id: string; token?: string; c?: string; p?: string; q?: string; from?: string; to?: string; sort?: string; status?: string; type?: string; name?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCampaignIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/campaign/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["type"] !== undefined) {
            urlObj.query["type"] = params["type"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adChangeCreativesStatusIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adChangeCreativesStatusIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adChangeCreativesStatusIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/change-creatives-status/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adCreativeIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    adCreativeIdGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adCreativeIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/creative/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adCreativeRejectReasonsGet
     * @param token the security token, get it from login route param
     */
    adCreativeRejectReasonsGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/creative-reject-reasons`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adNativeIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adNativeIdPut(params: { id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adNativeIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/native/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * adNativePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    adNativePost(params: { token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/ad/native`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetBrowserGet
     * @param token the security token, get it from login route param
     */
    assetBrowserGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/browser`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetCategoryGet
     * @param token the security token, get it from login route param
     */
    assetCategoryGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/category`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetIspKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetIspKindGet(params: { kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetIspKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/isp/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetManufacturersGet
     * @param token the security token, get it from login route param
     */
    assetManufacturersGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/manufacturers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsGet
     * @param token the security token, get it from login route param
     */
    assetOsGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetOsKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetOsKindGet(params: { kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetOsKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/os/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetPlatformGet
     * @param token the security token, get it from login route param
     */
    assetPlatformGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/platform`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * assetPlatformKindGet
     * @param kind  param
     * @param token the security token, get it from login route param
     */
    assetPlatformKindGet(params: { kind: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "kind" is set
        if (params["kind"] == null) {
            throw new Error("Missing required parameter kind when calling assetPlatformKindGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/asset/platform/{kind}`
            .replace(`{${"kind"}}`, `${ params["kind"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignArchiveIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignArchiveIdPatch(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignArchiveIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/archive/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignAttributesIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignAttributesIdPut(params: { id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignAttributesIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/attributes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignBaseIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignBaseIdPut(params: { id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignBaseIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/base/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignBudgetIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignBudgetIdPut(params: { id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignBudgetIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/budget/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCopyIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignCopyIdPatch(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignCopyIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/copy/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCreatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignCreatePost(params: { token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignCreativeIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignCreativeIdGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignCreativeIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/creative/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignDailyIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignDailyIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignDailyIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/daily/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignDailyIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param q  parameter for search param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param p  page number param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     */
    campaignDailyIdGet(params: { id: string; token?: string; c?: string; q?: string; to?: string; p?: string; from?: string; sort?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignDailyIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/daily/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignFinalizeIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignFinalizeIdPut(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignFinalizeIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/finalize/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGetIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignGetIdGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGetIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/get/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGraphAllGet
     * @param token the security token, get it from login route param
     * @param ownerEmail  search the owner_email field param
     * @param title  search the title field param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param kind  param
     */
    campaignGraphAllGet(params: { token?: string; ownerEmail?: string; title?: string; from?: string; to?: string; kind?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/graph/all`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["ownerEmail"] !== undefined) {
            urlObj.query["owner_email"] = params["ownerEmail"];
        }
        if (params["title"] !== undefined) {
            urlObj.query["title"] = params["title"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignGraphDailyIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    campaignGraphDailyIdGet(params: { id: string; token?: string; from?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGraphDailyIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/graph/daily/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignInventoryIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignInventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignInventoryIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/inventory/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignListDefinitionGet
     * @param token the security token, get it from login route param
     */
    campaignListDefinitionGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignListGet
     * @param token the security token, get it from login route param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param strategy  param
     * @param exchange  param
     * @param status  param
     * @param ownerEmail  search the owner_email field param
     * @param c  count per page param
     * @param sort  param
     * @param p  page number param
     * @param q  parameter for search param
     * @param kind  param
     * @param title  search the title field param
     */
    campaignListGet(params: { token?: string; from?: string; to?: string; strategy?: string; exchange?: string; status?: string; ownerEmail?: string; c?: string; sort?: string; p?: string; q?: string; kind?: string; title?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["strategy"] !== undefined) {
            urlObj.query["strategy"] = params["strategy"];
        }
        if (params["exchange"] !== undefined) {
            urlObj.query["exchange"] = params["exchange"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["ownerEmail"] !== undefined) {
            urlObj.query["owner_email"] = params["ownerEmail"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["title"] !== undefined) {
            urlObj.query["title"] = params["title"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignProgressIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignProgressIdGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignProgressIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/progress/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignPublisherDetailsIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    campaignPublisherDetailsIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignPublisherDetailsIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/publisher-details/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignPublisherDetailsIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param q  parameter for search param
     * @param p  page number param
     * @param domain  search the domain field param
     * @param c  count per page param
     */
    campaignPublisherDetailsIdGet(params: { id: string; token?: string; from?: string; to?: string; sort?: string; q?: string; p?: string; domain?: string; c?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignPublisherDetailsIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/publisher-details/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * campaignStatusIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    campaignStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignStatusIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/campaign/status/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * domainCreatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    domainCreatePost(params: { token?: string; payloadData?: ControllersCreateDomainPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/domain/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialAddPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialAddPost(params: { token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/add`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialBillingDefinitionGet
     * @param token the security token, get it from login route param
     */
    financialBillingDefinitionGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/billing/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialBillingGet
     * @param token the security token, get it from login route param
     * @param c  count per page param
     * @param userId  search the user_id field param
     * @param q  parameter for search param
     * @param sort  param
     * @param payModel  param
     * @param firstName  search the first_name field param
     * @param email  search the email field param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param lastName  search the last_name field param
     * @param p  page number param
     */
    financialBillingGet(params: { token?: string; c?: string; userId?: string; q?: string; sort?: string; payModel?: string; firstName?: string; email?: string; from?: string; to?: string; lastName?: string; p?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/billing`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["userId"] !== undefined) {
            urlObj.query["user_id"] = params["userId"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["payModel"] !== undefined) {
            urlObj.query["pay_model"] = params["payModel"];
        }
        if (params["firstName"] !== undefined) {
            urlObj.query["first_name"] = params["firstName"];
        }
        if (params["email"] !== undefined) {
            urlObj.query["email"] = params["email"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["lastName"] !== undefined) {
            urlObj.query["last_name"] = params["lastName"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGatewaysGet
     * @param token the security token, get it from login route param
     */
    financialGatewaysGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/gateways`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGatewaysIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     */
    financialGatewaysIdPatch(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling financialGatewaysIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/gateways/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGatewaysIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialGatewaysIdPut(params: { id: string; token?: string; payloadData?: ControllersEditGatewayPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling financialGatewaysIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/gateways/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGatewaysPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialGatewaysPost(params: { token?: string; payloadData?: ControllersAddGatewayPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/gateways`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGet
     * @param token the security token, get it from login route param
     */
    financialGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialGraphSpendGet
     * @param token the security token, get it from login route param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    financialGraphSpendGet(params: { token?: string; to?: string; from?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/graph/spend`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialManualChangeCashPut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialManualChangeCashPut(params: { token?: string; payloadData?: ControllersChangeCashStatus; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/manual-change-cash`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialPaymentIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    financialPaymentIdGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling financialPaymentIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/payment/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialPaymentInitPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    financialPaymentInitPost(params: { token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/financial/payment/init`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * financialPaymentReturnBankHashPost
     * @param bank  param
     * @param hash  param
     */
    financialPaymentReturnBankHashPost(params: { bank: string; hash: string; }, options: any = {}): FetchArgs {
        // verify required parameter "bank" is set
        if (params["bank"] == null) {
            throw new Error("Missing required parameter bank when calling financialPaymentReturnBankHashPost");
        }
        // verify required parameter "hash" is set
        if (params["hash"] == null) {
            throw new Error("Missing required parameter hash when calling financialPaymentReturnBankHashPost");
        }
        const baseUrl = `/financial/payment/return/{bank}/{hash}`
            .replace(`{${"bank"}}`, `${ params["bank"] }`)
            .replace(`{${"hash"}}`, `${ params["hash"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryAddpubIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryAddpubIdPatch(params: { id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryAddpubIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/addpub/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryBasePublishersStatisticsDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryBasePublishersStatisticsDefinitionGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/base-publishers/statistics/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryBasePublishersStatisticsGet
     * @param token the security token, get it from login route param
     * @param name  search the name field param
     * @param supplier  search the supplier field param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param status  param
     * @param c  count per page param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param domain  search the domain field param
     * @param p  page number param
     * @param kind  param
     */
    inventoryBasePublishersStatisticsGet(params: { token?: string; name?: string; supplier?: string; q?: string; from?: string; status?: string; c?: string; to?: string; domain?: string; p?: string; kind?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/base-publishers/statistics`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["supplier"] !== undefined) {
            urlObj.query["supplier"] = params["supplier"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryCreatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryCreatePost(params: { token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryDuplicatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryDuplicatePost(params: { token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/duplicate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryInventoryIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryInventoryIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryInventoryIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/inventory/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryInventoryListDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryInventoryListDefinitionGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/inventory/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryInventoryListGet
     * @param token the security token, get it from login route param
     * @param label  search the label field param
     * @param c  count per page param
     * @param p  page number param
     * @param q  parameter for search param
     * @param sort  param
     * @param status  param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     */
    inventoryInventoryListGet(params: { token?: string; label?: string; c?: string; p?: string; q?: string; sort?: string; status?: string; from?: string; to?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/inventory/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["label"] !== undefined) {
            urlObj.query["label"] = params["label"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListDefinitionGet
     * @param token the security token, get it from login route param
     */
    inventoryPublisherListDefinitionGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListGet
     * @param token the security token, get it from login route param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param name  search the name field param
     * @param p  page number param
     * @param q  parameter for search param
     * @param kind  param
     * @param status  param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param domain  search the domain field param
     * @param supplier  search the supplier field param
     * @param c  count per page param
     */
    inventoryPublisherListGet(params: { token?: string; to?: string; name?: string; p?: string; q?: string; kind?: string; status?: string; from?: string; sort?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        if (params["supplier"] !== undefined) {
            urlObj.query["supplier"] = params["supplier"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListSingleIdDefinitionGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    inventoryPublisherListSingleIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPublisherListSingleIdDefinitionGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list/single/{id}/definition`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryPublisherListSingleIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param kind  param
     * @param p  page number param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param sort  param
     * @param status  param
     * @param supplier  search the supplier field param
     * @param c  count per page param
     * @param name  search the name field param
     * @param domain  search the domain field param
     */
    inventoryPublisherListSingleIdGet(params: { id: string; token?: string; to?: string; kind?: string; p?: string; q?: string; from?: string; sort?: string; status?: string; supplier?: string; c?: string; name?: string; domain?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryPublisherListSingleIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/publisher/list/single/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["kind"] !== undefined) {
            urlObj.query["kind"] = params["kind"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        if (params["supplier"] !== undefined) {
            urlObj.query["supplier"] = params["supplier"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["domain"] !== undefined) {
            urlObj.query["domain"] = params["domain"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * inventoryRemovepubIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    inventoryRemovepubIdPatch(params: { id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling inventoryRemovepubIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/inventory/removepub/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadModuleModulePost
     * @param module  param
     * @param token the security token, get it from login route param
     */
    uploadModuleModulePost(params: { module: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "module" is set
        if (params["module"] == null) {
            throw new Error("Missing required parameter module when calling uploadModuleModulePost");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/module/{module}`
            .replace(`{${"module"}}`, `${ params["module"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * uploadVideoIdGet
     * @param id  param
     * @param token the security token, get it from login route param
     */
    uploadVideoIdGet(params: { id: string; token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling uploadVideoIdGet");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/upload/video/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ControllersApi - functional programming interface
 */
export const ControllersApiFp = {
    /**
     * adCampaignCreativeStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adCampaignCreativeStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatus; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCreativeStatusChangeResult> {
        // check permission for adCampaignCreativeStatusIdPatch
        if (permMap.adCampaignCreativeStatusIdPatch.protected && !AAA.getInstance().hasPerm(permMap.adCampaignCreativeStatusIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adCampaignCreativeStatusIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adCampaignIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCampaignIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCreativecampaignreportDefResponse> {
        // check permission for adCampaignIdDefinitionGet
        if (permMap.adCampaignIdDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.adCampaignIdDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adCampaignIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adCampaignIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param status  (def)
     * @param type  (def)
     * @param name  search the name field (def)
     */
    adCampaignIdGet(params: { id: string; token?: string; c?: string; p?: string; q?: string; from?: string; to?: string; sort?: string; status?: string; type?: string; name?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCreativecampaignreportResponse> {
        // check permission for adCampaignIdGet
        if (permMap.adCampaignIdGet.protected && !AAA.getInstance().hasPerm(permMap.adCampaignIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adCampaignIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adChangeCreativesStatusIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adChangeCreativesStatusIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersChangeStatusResult> {
        // check permission for adChangeCreativesStatusIdPut
        if (permMap.adChangeCreativesStatusIdPut.protected && !AAA.getInstance().hasPerm(permMap.adChangeCreativesStatusIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adChangeCreativesStatusIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCreativeIdGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        // check permission for adCreativeIdGet
        if (permMap.adCreativeIdGet.protected && !AAA.getInstance().hasPerm(permMap.adCreativeIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adCreativeIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adCreativeRejectReasonsGet
     * @param token the security token, get it from login route (def)
     */
    adCreativeRejectReasonsGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersRejectReasons> {
        // check permission for adCreativeRejectReasonsGet
        if (permMap.adCreativeRejectReasonsGet.protected && !AAA.getInstance().hasPerm(permMap.adCreativeRejectReasonsGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adCreativeRejectReasonsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adNativeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativeIdPut(params: { id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        // check permission for adNativeIdPut
        if (permMap.adNativeIdPut.protected && !AAA.getInstance().hasPerm(permMap.adNativeIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adNativeIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * adNativePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativePost(params: { token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCreativeSaveResult> {
        // check permission for adNativePost
        if (permMap.adNativePost.protected && !AAA.getInstance().hasPerm(permMap.adNativePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.adNativePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBrowserResponse> {
        // check permission for assetBrowserGet
        if (permMap.assetBrowserGet.protected && !AAA.getInstance().hasPerm(permMap.assetBrowserGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetBrowserGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCatResponse> {
        // check permission for assetCategoryGet
        if (permMap.assetCategoryGet.protected && !AAA.getInstance().hasPerm(permMap.assetCategoryGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetCategoryGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetIspKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetIspKindGet(params: { kind: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersIspResponse> {
        // check permission for assetIspKindGet
        if (permMap.assetIspKindGet.protected && !AAA.getInstance().hasPerm(permMap.assetIspKindGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetIspKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersManufacturers> {
        // check permission for assetManufacturersGet
        if (permMap.assetManufacturersGet.protected && !AAA.getInstance().hasPerm(permMap.assetManufacturersGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetManufacturersGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        // check permission for assetOsGet
        if (permMap.assetOsGet.protected && !AAA.getInstance().hasPerm(permMap.assetOsGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetOsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetOsKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetOsKindGet(params: { kind: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersOsResponse> {
        // check permission for assetOsKindGet
        if (permMap.assetOsKindGet.protected && !AAA.getInstance().hasPerm(permMap.assetOsKindGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetOsKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetPlatformGet
     * @param token the security token, get it from login route (def)
     */
    assetPlatformGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersPlatformResponse> {
        // check permission for assetPlatformGet
        if (permMap.assetPlatformGet.protected && !AAA.getInstance().hasPerm(permMap.assetPlatformGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetPlatformGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * assetPlatformKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetPlatformKindGet(params: { kind: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersPlatformResponse> {
        // check permission for assetPlatformKindGet
        if (permMap.assetPlatformKindGet.protected && !AAA.getInstance().hasPerm(permMap.assetPlatformKindGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.assetPlatformKindGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignArchiveIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignArchiveIdPatch(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for campaignArchiveIdPatch
        if (permMap.campaignArchiveIdPatch.protected && !AAA.getInstance().hasPerm(permMap.campaignArchiveIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignArchiveIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignAttributesIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignAttributesIdPut(params: { id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersAttributesResult> {
        // check permission for campaignAttributesIdPut
        if (permMap.campaignAttributesIdPut.protected && !AAA.getInstance().hasPerm(permMap.campaignAttributesIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignAttributesIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignBaseIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBaseIdPut(params: { id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersUpdateResult> {
        // check permission for campaignBaseIdPut
        if (permMap.campaignBaseIdPut.protected && !AAA.getInstance().hasPerm(permMap.campaignBaseIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignBaseIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignBudgetIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBudgetIdPut(params: { id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        // check permission for campaignBudgetIdPut
        if (permMap.campaignBudgetIdPut.protected && !AAA.getInstance().hasPerm(permMap.campaignBudgetIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignBudgetIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignCopyIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignCopyIdPatch(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        // check permission for campaignCopyIdPatch
        if (permMap.campaignCopyIdPatch.protected && !AAA.getInstance().hasPerm(permMap.campaignCopyIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignCopyIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCreatePost(params: { token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersBaseResult> {
        // check permission for campaignCreatePost
        if (permMap.campaignCreatePost.protected && !AAA.getInstance().hasPerm(permMap.campaignCreatePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignCreatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignCreativeIdGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetCreativeResp> {
        // check permission for campaignCreativeIdGet
        if (permMap.campaignCreativeIdGet.protected && !AAA.getInstance().hasPerm(permMap.campaignCreativeIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignCreativeIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignDailyIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignDailyIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaigndailyDefResponse> {
        // check permission for campaignDailyIdDefinitionGet
        if (permMap.campaignDailyIdDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.campaignDailyIdDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignDailyIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     */
    campaignDailyIdGet(params: { id: string; token?: string; c?: string; q?: string; to?: string; p?: string; from?: string; sort?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaigndailyResponse> {
        // check permission for campaignDailyIdGet
        if (permMap.campaignDailyIdGet.protected && !AAA.getInstance().hasPerm(permMap.campaignDailyIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignDailyIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignFinalizeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignFinalizeIdPut(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersFinalizeResult> {
        // check permission for campaignFinalizeIdPut
        if (permMap.campaignFinalizeIdPut.protected && !AAA.getInstance().hasPerm(permMap.campaignFinalizeIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignFinalizeIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignGetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCampaignGetResponse> {
        // check permission for campaignGetIdGet
        if (permMap.campaignGetIdGet.protected && !AAA.getInstance().hasPerm(permMap.campaignGetIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignGetIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignGraphAllGet
     * @param token the security token, get it from login route (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param title  search the title field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     */
    campaignGraphAllGet(params: { token?: string; ownerEmail?: string; title?: string; from?: string; to?: string; kind?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGraphChartallResponse> {
        // check permission for campaignGraphAllGet
        if (permMap.campaignGraphAllGet.protected && !AAA.getInstance().hasPerm(permMap.campaignGraphAllGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignGraphAllGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignGraphDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignGraphDailyIdGet(params: { id: string; token?: string; from?: string; to?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGraphChartdailyResponse> {
        // check permission for campaignGraphDailyIdGet
        if (permMap.campaignGraphDailyIdGet.protected && !AAA.getInstance().hasPerm(permMap.campaignGraphDailyIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignGraphDailyIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignInventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignInventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaign> {
        // check permission for campaignInventoryIdPut
        if (permMap.campaignInventoryIdPut.protected && !AAA.getInstance().hasPerm(permMap.campaignInventoryIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignInventoryIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    campaignListDefinitionGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaignsDefResponse> {
        // check permission for campaignListDefinitionGet
        if (permMap.campaignListDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.campaignListDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignListGet
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param strategy  (def)
     * @param exchange  (def)
     * @param status  (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param c  count per page (def)
     * @param sort  (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param kind  (def)
     * @param title  search the title field (def)
     */
    campaignListGet(params: { token?: string; from?: string; to?: string; strategy?: string; exchange?: string; status?: string; ownerEmail?: string; c?: string; sort?: string; p?: string; q?: string; kind?: string; title?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListCampaignsResponse> {
        // check permission for campaignListGet
        if (permMap.campaignListGet.protected && !AAA.getInstance().hasPerm(permMap.campaignListGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignProgressIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignProgressIdGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmCampaignProgress> {
        // check permission for campaignProgressIdGet
        if (permMap.campaignProgressIdGet.protected && !AAA.getInstance().hasPerm(permMap.campaignProgressIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignProgressIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignPublisherDetailsIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignPublisherDetailsIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherdetailsDefResponse> {
        // check permission for campaignPublisherDetailsIdDefinitionGet
        if (permMap.campaignPublisherDetailsIdDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.campaignPublisherDetailsIdDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignPublisherDetailsIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignPublisherDetailsIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param q  parameter for search (def)
     * @param p  page number (def)
     * @param domain  search the domain field (def)
     * @param c  count per page (def)
     */
    campaignPublisherDetailsIdGet(params: { id: string; token?: string; from?: string; to?: string; sort?: string; q?: string; p?: string; domain?: string; c?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherdetailsResponse> {
        // check permission for campaignPublisherDetailsIdGet
        if (permMap.campaignPublisherDetailsIdGet.protected && !AAA.getInstance().hasPerm(permMap.campaignPublisherDetailsIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignPublisherDetailsIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * campaignStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for campaignStatusIdPatch
        if (permMap.campaignStatusIdPatch.protected && !AAA.getInstance().hasPerm(permMap.campaignStatusIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.campaignStatusIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * domainCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    domainCreatePost(params: { token?: string; payloadData?: ControllersCreateDomainPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersCreateDomainResult> {
        // check permission for domainCreatePost
        if (permMap.domainCreatePost.protected && !AAA.getInstance().hasPerm(permMap.domainCreatePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.domainCreatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialAddPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialAddPost(params: { token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmBankSnap> {
        // check permission for financialAddPost
        if (permMap.financialAddPost.protected && !AAA.getInstance().hasPerm(permMap.financialAddPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialAddPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialBillingDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    financialBillingDefinitionGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListBillingreportDefResponse> {
        // check permission for financialBillingDefinitionGet
        if (permMap.financialBillingDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.financialBillingDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialBillingDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialBillingGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param userId  search the user_id field (def)
     * @param q  parameter for search (def)
     * @param sort  (def)
     * @param payModel  (def)
     * @param firstName  search the first_name field (def)
     * @param email  search the email field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param lastName  search the last_name field (def)
     * @param p  page number (def)
     */
    financialBillingGet(params: { token?: string; c?: string; userId?: string; q?: string; sort?: string; payModel?: string; firstName?: string; email?: string; from?: string; to?: string; lastName?: string; p?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListBillingreportResponse> {
        // check permission for financialBillingGet
        if (permMap.financialBillingGet.protected && !AAA.getInstance().hasPerm(permMap.financialBillingGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialBillingGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialGatewaysGet
     * @param token the security token, get it from login route (def)
     */
    financialGatewaysGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetGateResp> {
        // check permission for financialGatewaysGet
        if (permMap.financialGatewaysGet.protected && !AAA.getInstance().hasPerm(permMap.financialGatewaysGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialGatewaysGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialGatewaysIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    financialGatewaysIdPatch(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmGateway> {
        // check permission for financialGatewaysIdPatch
        if (permMap.financialGatewaysIdPatch.protected && !AAA.getInstance().hasPerm(permMap.financialGatewaysIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialGatewaysIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialGatewaysIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialGatewaysIdPut(params: { id: string; token?: string; payloadData?: ControllersEditGatewayPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmGateway> {
        // check permission for financialGatewaysIdPut
        if (permMap.financialGatewaysIdPut.protected && !AAA.getInstance().hasPerm(permMap.financialGatewaysIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialGatewaysIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialGatewaysPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialGatewaysPost(params: { token?: string; payloadData?: ControllersAddGatewayPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmGateway> {
        // check permission for financialGatewaysPost
        if (permMap.financialGatewaysPost.protected && !AAA.getInstance().hasPerm(permMap.financialGatewaysPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialGatewaysPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialGet
     * @param token the security token, get it from login route (def)
     */
    financialGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmBilling> {
        // check permission for financialGet
        if (permMap.financialGet.protected && !AAA.getInstance().hasPerm(permMap.financialGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialGraphSpendGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    financialGraphSpendGet(params: { token?: string; to?: string; from?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGraphBillinggraphreportResponse> {
        // check permission for financialGraphSpendGet
        if (permMap.financialGraphSpendGet.protected && !AAA.getInstance().hasPerm(permMap.financialGraphSpendGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialGraphSpendGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialManualChangeCashPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialManualChangeCashPut(params: { token?: string; payloadData?: ControllersChangeCashStatus; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersChangeCashResult> {
        // check permission for financialManualChangeCashPut
        if (permMap.financialManualChangeCashPut.protected && !AAA.getInstance().hasPerm(permMap.financialManualChangeCashPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialManualChangeCashPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialPaymentIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    financialPaymentIdGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmOnlinePayment> {
        // check permission for financialPaymentIdGet
        if (permMap.financialPaymentIdGet.protected && !AAA.getInstance().hasPerm(permMap.financialPaymentIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialPaymentIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialPaymentInitPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialPaymentInitPost(params: { token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentInitPaymentResp> {
        // check permission for financialPaymentInitPost
        if (permMap.financialPaymentInitPost.protected && !AAA.getInstance().hasPerm(permMap.financialPaymentInitPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialPaymentInitPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * financialPaymentReturnBankHashPost
     * @param bank  (def)
     * @param hash  (def)
     */
    financialPaymentReturnBankHashPost(params: { bank: string; hash: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        // check permission for financialPaymentReturnBankHashPost
        if (permMap.financialPaymentReturnBankHashPost.protected && !AAA.getInstance().hasPerm(permMap.financialPaymentReturnBankHashPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.financialPaymentReturnBankHashPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryAddpubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryAddpubIdPatch(params: { id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        // check permission for inventoryAddpubIdPatch
        if (permMap.inventoryAddpubIdPatch.protected && !AAA.getInstance().hasPerm(permMap.inventoryAddpubIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryAddpubIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryBasePublishersStatisticsDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryBasePublishersStatisticsDefinitionGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListBasePublisherStatisticsDefResponse> {
        // check permission for inventoryBasePublishersStatisticsDefinitionGet
        if (permMap.inventoryBasePublishersStatisticsDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryBasePublishersStatisticsDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryBasePublishersStatisticsDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryBasePublishersStatisticsGet
     * @param token the security token, get it from login route (def)
     * @param name  search the name field (def)
     * @param supplier  search the supplier field (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param status  (def)
     * @param c  count per page (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param domain  search the domain field (def)
     * @param p  page number (def)
     * @param kind  (def)
     */
    inventoryBasePublishersStatisticsGet(params: { token?: string; name?: string; supplier?: string; q?: string; from?: string; status?: string; c?: string; to?: string; domain?: string; p?: string; kind?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListBasePublisherStatisticsResponse> {
        // check permission for inventoryBasePublishersStatisticsGet
        if (permMap.inventoryBasePublishersStatisticsGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryBasePublishersStatisticsGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryBasePublishersStatisticsGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryCreatePost(params: { token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        // check permission for inventoryCreatePost
        if (permMap.inventoryCreatePost.protected && !AAA.getInstance().hasPerm(permMap.inventoryCreatePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryCreatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryDuplicatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryDuplicatePost(params: { token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        // check permission for inventoryDuplicatePost
        if (permMap.inventoryDuplicatePost.protected && !AAA.getInstance().hasPerm(permMap.inventoryDuplicatePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryDuplicatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        // check permission for inventoryIdPut
        if (permMap.inventoryIdPut.protected && !AAA.getInstance().hasPerm(permMap.inventoryIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryInventoryIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryInventoryIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        // check permission for inventoryInventoryIdPatch
        if (permMap.inventoryInventoryIdPatch.protected && !AAA.getInstance().hasPerm(permMap.inventoryInventoryIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryInventoryIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryInventoryListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryInventoryListDefinitionGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInventoryDefResponse> {
        // check permission for inventoryInventoryListDefinitionGet
        if (permMap.inventoryInventoryListDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryInventoryListDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryInventoryListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryInventoryListGet
     * @param token the security token, get it from login route (def)
     * @param label  search the label field (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param sort  (def)
     * @param status  (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    inventoryInventoryListGet(params: { token?: string; label?: string; c?: string; p?: string; q?: string; sort?: string; status?: string; from?: string; to?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInventoryResponse> {
        // check permission for inventoryInventoryListGet
        if (permMap.inventoryInventoryListGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryInventoryListGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryInventoryListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryPublisherListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListDefinitionGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherDefResponse> {
        // check permission for inventoryPublisherListDefinitionGet
        if (permMap.inventoryPublisherListDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryPublisherListDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryPublisherListGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param name  search the name field (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param kind  (def)
     * @param status  (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param domain  search the domain field (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     */
    inventoryPublisherListGet(params: { token?: string; to?: string; name?: string; p?: string; q?: string; kind?: string; status?: string; from?: string; sort?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListPublisherResponse> {
        // check permission for inventoryPublisherListGet
        if (permMap.inventoryPublisherListGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryPublisherListGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryPublisherListSingleIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListSingleIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInvpublisherDefResponse> {
        // check permission for inventoryPublisherListSingleIdDefinitionGet
        if (permMap.inventoryPublisherListSingleIdDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryPublisherListSingleIdDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListSingleIdDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryPublisherListSingleIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param status  (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     * @param name  search the name field (def)
     * @param domain  search the domain field (def)
     */
    inventoryPublisherListSingleIdGet(params: { id: string; token?: string; to?: string; kind?: string; p?: string; q?: string; from?: string; sort?: string; status?: string; supplier?: string; c?: string; name?: string; domain?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersListInvpublisherResponse> {
        // check permission for inventoryPublisherListSingleIdGet
        if (permMap.inventoryPublisherListSingleIdGet.protected && !AAA.getInstance().hasPerm(permMap.inventoryPublisherListSingleIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryPublisherListSingleIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * inventoryRemovepubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryRemovepubIdPatch(params: { id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OrmInventory> {
        // check permission for inventoryRemovepubIdPatch
        if (permMap.inventoryRemovepubIdPatch.protected && !AAA.getInstance().hasPerm(permMap.inventoryRemovepubIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.inventoryRemovepubIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * uploadModuleModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModuleModulePost(params: { module: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersUploadResponse> {
        // check permission for uploadModuleModulePost
        if (permMap.uploadModuleModulePost.protected && !AAA.getInstance().hasPerm(permMap.uploadModuleModulePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.uploadModuleModulePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * uploadVideoIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadVideoIdGet(params: { id: string; token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllersGetVideoResponse> {
        // check permission for uploadVideoIdGet
        if (permMap.uploadVideoIdGet.protected && !AAA.getInstance().hasPerm(permMap.uploadVideoIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = ControllersApiFetchParamCreator.uploadVideoIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
};

/**
 * ControllersApi - object-oriented interface
 */
export class ControllersApi extends BaseAPI {
    /**
     * adCampaignCreativeStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adCampaignCreativeStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatus; }, options: any = {}) {
        return ControllersApiFp.adCampaignCreativeStatusIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * adCampaignIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCampaignIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.adCampaignIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * adCampaignIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param status  (def)
     * @param type  (def)
     * @param name  search the name field (def)
     */
    adCampaignIdGet(params: { id: string; token?: string; c?: string; p?: string; q?: string; from?: string; to?: string; sort?: string; status?: string; type?: string; name?: string; }, options: any = {}) {
        return ControllersApiFp.adCampaignIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * adChangeCreativesStatusIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adChangeCreativesStatusIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}) {
        return ControllersApiFp.adChangeCreativesStatusIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * adCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    adCreativeIdGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.adCreativeIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * adCreativeRejectReasonsGet
     * @param token the security token, get it from login route (def)
     */
    adCreativeRejectReasonsGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.adCreativeRejectReasonsGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * adNativeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativeIdPut(params: { id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}) {
        return ControllersApiFp.adNativeIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * adNativePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    adNativePost(params: { token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}) {
        return ControllersApiFp.adNativePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetBrowserGet
     * @param token the security token, get it from login route (def)
     */
    assetBrowserGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.assetBrowserGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetCategoryGet
     * @param token the security token, get it from login route (def)
     */
    assetCategoryGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.assetCategoryGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetIspKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetIspKindGet(params: { kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetIspKindGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetManufacturersGet
     * @param token the security token, get it from login route (def)
     */
    assetManufacturersGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.assetManufacturersGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetOsGet
     * @param token the security token, get it from login route (def)
     */
    assetOsGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetOsKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetOsKindGet(params: { kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetOsKindGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetPlatformGet
     * @param token the security token, get it from login route (def)
     */
    assetPlatformGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.assetPlatformGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * assetPlatformKindGet
     * @param kind  (def)
     * @param token the security token, get it from login route (def)
     */
    assetPlatformKindGet(params: { kind: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.assetPlatformKindGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignArchiveIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignArchiveIdPatch(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignArchiveIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignAttributesIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignAttributesIdPut(params: { id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}) {
        return ControllersApiFp.campaignAttributesIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignBaseIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBaseIdPut(params: { id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}) {
        return ControllersApiFp.campaignBaseIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignBudgetIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignBudgetIdPut(params: { id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}) {
        return ControllersApiFp.campaignBudgetIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignCopyIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignCopyIdPatch(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignCopyIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignCreatePost(params: { token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}) {
        return ControllersApiFp.campaignCreatePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignCreativeIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignCreativeIdGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignCreativeIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignDailyIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignDailyIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignDailyIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param q  parameter for search (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param p  page number (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     */
    campaignDailyIdGet(params: { id: string; token?: string; c?: string; q?: string; to?: string; p?: string; from?: string; sort?: string; }, options: any = {}) {
        return ControllersApiFp.campaignDailyIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignFinalizeIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignFinalizeIdPut(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignFinalizeIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignGetIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignGetIdGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGetIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignGraphAllGet
     * @param token the security token, get it from login route (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param title  search the title field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     */
    campaignGraphAllGet(params: { token?: string; ownerEmail?: string; title?: string; from?: string; to?: string; kind?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGraphAllGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignGraphDailyIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    campaignGraphDailyIdGet(params: { id: string; token?: string; from?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.campaignGraphDailyIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignInventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignInventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.campaignInventoryIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    campaignListDefinitionGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignListDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignListGet
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param strategy  (def)
     * @param exchange  (def)
     * @param status  (def)
     * @param ownerEmail  search the owner_email field (def)
     * @param c  count per page (def)
     * @param sort  (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param kind  (def)
     * @param title  search the title field (def)
     */
    campaignListGet(params: { token?: string; from?: string; to?: string; strategy?: string; exchange?: string; status?: string; ownerEmail?: string; c?: string; sort?: string; p?: string; q?: string; kind?: string; title?: string; }, options: any = {}) {
        return ControllersApiFp.campaignListGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignProgressIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignProgressIdGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignProgressIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignPublisherDetailsIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    campaignPublisherDetailsIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.campaignPublisherDetailsIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignPublisherDetailsIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param q  parameter for search (def)
     * @param p  page number (def)
     * @param domain  search the domain field (def)
     * @param c  count per page (def)
     */
    campaignPublisherDetailsIdGet(params: { id: string; token?: string; from?: string; to?: string; sort?: string; q?: string; p?: string; domain?: string; c?: string; }, options: any = {}) {
        return ControllersApiFp.campaignPublisherDetailsIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * campaignStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    campaignStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}) {
        return ControllersApiFp.campaignStatusIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * domainCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    domainCreatePost(params: { token?: string; payloadData?: ControllersCreateDomainPayload; }, options: any = {}) {
        return ControllersApiFp.domainCreatePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialAddPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialAddPost(params: { token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}) {
        return ControllersApiFp.financialAddPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialBillingDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    financialBillingDefinitionGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.financialBillingDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialBillingGet
     * @param token the security token, get it from login route (def)
     * @param c  count per page (def)
     * @param userId  search the user_id field (def)
     * @param q  parameter for search (def)
     * @param sort  (def)
     * @param payModel  (def)
     * @param firstName  search the first_name field (def)
     * @param email  search the email field (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param lastName  search the last_name field (def)
     * @param p  page number (def)
     */
    financialBillingGet(params: { token?: string; c?: string; userId?: string; q?: string; sort?: string; payModel?: string; firstName?: string; email?: string; from?: string; to?: string; lastName?: string; p?: string; }, options: any = {}) {
        return ControllersApiFp.financialBillingGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialGatewaysGet
     * @param token the security token, get it from login route (def)
     */
    financialGatewaysGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.financialGatewaysGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialGatewaysIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    financialGatewaysIdPatch(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.financialGatewaysIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialGatewaysIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialGatewaysIdPut(params: { id: string; token?: string; payloadData?: ControllersEditGatewayPayload; }, options: any = {}) {
        return ControllersApiFp.financialGatewaysIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialGatewaysPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialGatewaysPost(params: { token?: string; payloadData?: ControllersAddGatewayPayload; }, options: any = {}) {
        return ControllersApiFp.financialGatewaysPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialGet
     * @param token the security token, get it from login route (def)
     */
    financialGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.financialGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialGraphSpendGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    financialGraphSpendGet(params: { token?: string; to?: string; from?: string; }, options: any = {}) {
        return ControllersApiFp.financialGraphSpendGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialManualChangeCashPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialManualChangeCashPut(params: { token?: string; payloadData?: ControllersChangeCashStatus; }, options: any = {}) {
        return ControllersApiFp.financialManualChangeCashPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialPaymentIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    financialPaymentIdGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.financialPaymentIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialPaymentInitPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    financialPaymentInitPost(params: { token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}) {
        return ControllersApiFp.financialPaymentInitPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * financialPaymentReturnBankHashPost
     * @param bank  (def)
     * @param hash  (def)
     */
    financialPaymentReturnBankHashPost(params: { bank: string; hash: string; }, options: any = {}) {
        return ControllersApiFp.financialPaymentReturnBankHashPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryAddpubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryAddpubIdPatch(params: { id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryAddpubIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryBasePublishersStatisticsDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryBasePublishersStatisticsDefinitionGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryBasePublishersStatisticsDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryBasePublishersStatisticsGet
     * @param token the security token, get it from login route (def)
     * @param name  search the name field (def)
     * @param supplier  search the supplier field (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param status  (def)
     * @param c  count per page (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param domain  search the domain field (def)
     * @param p  page number (def)
     * @param kind  (def)
     */
    inventoryBasePublishersStatisticsGet(params: { token?: string; name?: string; supplier?: string; q?: string; from?: string; status?: string; c?: string; to?: string; domain?: string; p?: string; kind?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryBasePublishersStatisticsGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryCreatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryCreatePost(params: { token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryCreatePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryDuplicatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryDuplicatePost(params: { token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryDuplicatePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryInventoryIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryInventoryIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryInventoryIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryInventoryListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryInventoryListDefinitionGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryInventoryListDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryInventoryListGet
     * @param token the security token, get it from login route (def)
     * @param label  search the label field (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param sort  (def)
     * @param status  (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     */
    inventoryInventoryListGet(params: { token?: string; label?: string; c?: string; p?: string; q?: string; sort?: string; status?: string; from?: string; to?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryInventoryListGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryPublisherListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListDefinitionGet(params: { token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryPublisherListGet
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param name  search the name field (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param kind  (def)
     * @param status  (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param domain  search the domain field (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     */
    inventoryPublisherListGet(params: { token?: string; to?: string; name?: string; p?: string; q?: string; kind?: string; status?: string; from?: string; sort?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryPublisherListSingleIdDefinitionGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    inventoryPublisherListSingleIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListSingleIdDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryPublisherListSingleIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param kind  (def)
     * @param p  page number (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param sort  (def)
     * @param status  (def)
     * @param supplier  search the supplier field (def)
     * @param c  count per page (def)
     * @param name  search the name field (def)
     * @param domain  search the domain field (def)
     */
    inventoryPublisherListSingleIdGet(params: { id: string; token?: string; to?: string; kind?: string; p?: string; q?: string; from?: string; sort?: string; status?: string; supplier?: string; c?: string; name?: string; domain?: string; }, options: any = {}) {
        return ControllersApiFp.inventoryPublisherListSingleIdGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * inventoryRemovepubIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    inventoryRemovepubIdPatch(params: { id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}) {
        return ControllersApiFp.inventoryRemovepubIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * uploadModuleModulePost
     * @param module  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadModuleModulePost(params: { module: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadModuleModulePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * uploadVideoIdGet
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     */
    uploadVideoIdGet(params: { id: string; token?: string; }, options: any = {}) {
        return ControllersApiFp.uploadVideoIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * ControllersApi - factory interface
 */
export const ControllersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * adCampaignCreativeStatusIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adCampaignCreativeStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatus; }, options: any = {}) {
            return ControllersApiFp.adCampaignCreativeStatusIdPatch(params, options)(fetch, basePath);
        },
        /**
         * adCampaignIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        adCampaignIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.adCampaignIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * adCampaignIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param status  (def)
         * @param type  (def)
         * @param name  search the name field (def)
         */
        adCampaignIdGet(params: { id: string; token?: string; c?: string; p?: string; q?: string; from?: string; to?: string; sort?: string; status?: string; type?: string; name?: string; }, options: any = {}) {
            return ControllersApiFp.adCampaignIdGet(params, options)(fetch, basePath);
        },
        /**
         * adChangeCreativesStatusIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adChangeCreativesStatusIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}) {
            return ControllersApiFp.adChangeCreativesStatusIdPut(params, options)(fetch, basePath);
        },
        /**
         * adCreativeIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        adCreativeIdGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.adCreativeIdGet(params, options)(fetch, basePath);
        },
        /**
         * adCreativeRejectReasonsGet
         * @param token the security token, get it from login route (def)
         */
        adCreativeRejectReasonsGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.adCreativeRejectReasonsGet(params, options)(fetch, basePath);
        },
        /**
         * adNativeIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adNativeIdPut(params: { id: string; token?: string; payloadData?: ControllersEditNativePayload; }, options: any = {}) {
            return ControllersApiFp.adNativeIdPut(params, options)(fetch, basePath);
        },
        /**
         * adNativePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        adNativePost(params: { token?: string; payloadData?: ControllersCreateNativePayload; }, options: any = {}) {
            return ControllersApiFp.adNativePost(params, options)(fetch, basePath);
        },
        /**
         * assetBrowserGet
         * @param token the security token, get it from login route (def)
         */
        assetBrowserGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.assetBrowserGet(params, options)(fetch, basePath);
        },
        /**
         * assetCategoryGet
         * @param token the security token, get it from login route (def)
         */
        assetCategoryGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.assetCategoryGet(params, options)(fetch, basePath);
        },
        /**
         * assetIspKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetIspKindGet(params: { kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetIspKindGet(params, options)(fetch, basePath);
        },
        /**
         * assetManufacturersGet
         * @param token the security token, get it from login route (def)
         */
        assetManufacturersGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.assetManufacturersGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsGet
         * @param token the security token, get it from login route (def)
         */
        assetOsGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsGet(params, options)(fetch, basePath);
        },
        /**
         * assetOsKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetOsKindGet(params: { kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetOsKindGet(params, options)(fetch, basePath);
        },
        /**
         * assetPlatformGet
         * @param token the security token, get it from login route (def)
         */
        assetPlatformGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.assetPlatformGet(params, options)(fetch, basePath);
        },
        /**
         * assetPlatformKindGet
         * @param kind  (def)
         * @param token the security token, get it from login route (def)
         */
        assetPlatformKindGet(params: { kind: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.assetPlatformKindGet(params, options)(fetch, basePath);
        },
        /**
         * campaignArchiveIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignArchiveIdPatch(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignArchiveIdPatch(params, options)(fetch, basePath);
        },
        /**
         * campaignAttributesIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignAttributesIdPut(params: { id: string; token?: string; payloadData?: ControllersAttributesPayload; }, options: any = {}) {
            return ControllersApiFp.campaignAttributesIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignBaseIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignBaseIdPut(params: { id: string; token?: string; payloadData?: ControllersCampaignBase; }, options: any = {}) {
            return ControllersApiFp.campaignBaseIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignBudgetIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignBudgetIdPut(params: { id: string; token?: string; payloadData?: ControllersBudgetPayload; }, options: any = {}) {
            return ControllersApiFp.campaignBudgetIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignCopyIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignCopyIdPatch(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignCopyIdPatch(params, options)(fetch, basePath);
        },
        /**
         * campaignCreatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignCreatePost(params: { token?: string; payloadData?: ControllersCreateCampaignPayload; }, options: any = {}) {
            return ControllersApiFp.campaignCreatePost(params, options)(fetch, basePath);
        },
        /**
         * campaignCreativeIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignCreativeIdGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignCreativeIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignDailyIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignDailyIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignDailyIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignDailyIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param q  parameter for search (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param p  page number (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         */
        campaignDailyIdGet(params: { id: string; token?: string; c?: string; q?: string; to?: string; p?: string; from?: string; sort?: string; }, options: any = {}) {
            return ControllersApiFp.campaignDailyIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignFinalizeIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignFinalizeIdPut(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignFinalizeIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignGetIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignGetIdGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGetIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignGraphAllGet
         * @param token the security token, get it from login route (def)
         * @param ownerEmail  search the owner_email field (def)
         * @param title  search the title field (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param kind  (def)
         */
        campaignGraphAllGet(params: { token?: string; ownerEmail?: string; title?: string; from?: string; to?: string; kind?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGraphAllGet(params, options)(fetch, basePath);
        },
        /**
         * campaignGraphDailyIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        campaignGraphDailyIdGet(params: { id: string; token?: string; from?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.campaignGraphDailyIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignInventoryIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignInventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersAssignInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.campaignInventoryIdPut(params, options)(fetch, basePath);
        },
        /**
         * campaignListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        campaignListDefinitionGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignListGet
         * @param token the security token, get it from login route (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param strategy  (def)
         * @param exchange  (def)
         * @param status  (def)
         * @param ownerEmail  search the owner_email field (def)
         * @param c  count per page (def)
         * @param sort  (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param kind  (def)
         * @param title  search the title field (def)
         */
        campaignListGet(params: { token?: string; from?: string; to?: string; strategy?: string; exchange?: string; status?: string; ownerEmail?: string; c?: string; sort?: string; p?: string; q?: string; kind?: string; title?: string; }, options: any = {}) {
            return ControllersApiFp.campaignListGet(params, options)(fetch, basePath);
        },
        /**
         * campaignProgressIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignProgressIdGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignProgressIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignPublisherDetailsIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        campaignPublisherDetailsIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.campaignPublisherDetailsIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * campaignPublisherDetailsIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param q  parameter for search (def)
         * @param p  page number (def)
         * @param domain  search the domain field (def)
         * @param c  count per page (def)
         */
        campaignPublisherDetailsIdGet(params: { id: string; token?: string; from?: string; to?: string; sort?: string; q?: string; p?: string; domain?: string; c?: string; }, options: any = {}) {
            return ControllersApiFp.campaignPublisherDetailsIdGet(params, options)(fetch, basePath);
        },
        /**
         * campaignStatusIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        campaignStatusIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeCampaignStatus; }, options: any = {}) {
            return ControllersApiFp.campaignStatusIdPatch(params, options)(fetch, basePath);
        },
        /**
         * domainCreatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        domainCreatePost(params: { token?: string; payloadData?: ControllersCreateDomainPayload; }, options: any = {}) {
            return ControllersApiFp.domainCreatePost(params, options)(fetch, basePath);
        },
        /**
         * financialAddPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialAddPost(params: { token?: string; payloadData?: ControllersRegisterBankSnapPayload; }, options: any = {}) {
            return ControllersApiFp.financialAddPost(params, options)(fetch, basePath);
        },
        /**
         * financialBillingDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        financialBillingDefinitionGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.financialBillingDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * financialBillingGet
         * @param token the security token, get it from login route (def)
         * @param c  count per page (def)
         * @param userId  search the user_id field (def)
         * @param q  parameter for search (def)
         * @param sort  (def)
         * @param payModel  (def)
         * @param firstName  search the first_name field (def)
         * @param email  search the email field (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param lastName  search the last_name field (def)
         * @param p  page number (def)
         */
        financialBillingGet(params: { token?: string; c?: string; userId?: string; q?: string; sort?: string; payModel?: string; firstName?: string; email?: string; from?: string; to?: string; lastName?: string; p?: string; }, options: any = {}) {
            return ControllersApiFp.financialBillingGet(params, options)(fetch, basePath);
        },
        /**
         * financialGatewaysGet
         * @param token the security token, get it from login route (def)
         */
        financialGatewaysGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.financialGatewaysGet(params, options)(fetch, basePath);
        },
        /**
         * financialGatewaysIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        financialGatewaysIdPatch(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.financialGatewaysIdPatch(params, options)(fetch, basePath);
        },
        /**
         * financialGatewaysIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialGatewaysIdPut(params: { id: string; token?: string; payloadData?: ControllersEditGatewayPayload; }, options: any = {}) {
            return ControllersApiFp.financialGatewaysIdPut(params, options)(fetch, basePath);
        },
        /**
         * financialGatewaysPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialGatewaysPost(params: { token?: string; payloadData?: ControllersAddGatewayPayload; }, options: any = {}) {
            return ControllersApiFp.financialGatewaysPost(params, options)(fetch, basePath);
        },
        /**
         * financialGet
         * @param token the security token, get it from login route (def)
         */
        financialGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.financialGet(params, options)(fetch, basePath);
        },
        /**
         * financialGraphSpendGet
         * @param token the security token, get it from login route (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        financialGraphSpendGet(params: { token?: string; to?: string; from?: string; }, options: any = {}) {
            return ControllersApiFp.financialGraphSpendGet(params, options)(fetch, basePath);
        },
        /**
         * financialManualChangeCashPut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialManualChangeCashPut(params: { token?: string; payloadData?: ControllersChangeCashStatus; }, options: any = {}) {
            return ControllersApiFp.financialManualChangeCashPut(params, options)(fetch, basePath);
        },
        /**
         * financialPaymentIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        financialPaymentIdGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.financialPaymentIdGet(params, options)(fetch, basePath);
        },
        /**
         * financialPaymentInitPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        financialPaymentInitPost(params: { token?: string; payloadData?: ControllersInitPaymentPayload; }, options: any = {}) {
            return ControllersApiFp.financialPaymentInitPost(params, options)(fetch, basePath);
        },
        /**
         * financialPaymentReturnBankHashPost
         * @param bank  (def)
         * @param hash  (def)
         */
        financialPaymentReturnBankHashPost(params: { bank: string; hash: string; }, options: any = {}) {
            return ControllersApiFp.financialPaymentReturnBankHashPost(params, options)(fetch, basePath);
        },
        /**
         * inventoryAddpubIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryAddpubIdPatch(params: { id: string; token?: string; payloadData?: ControllersAddInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryAddpubIdPatch(params, options)(fetch, basePath);
        },
        /**
         * inventoryBasePublishersStatisticsDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryBasePublishersStatisticsDefinitionGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryBasePublishersStatisticsDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryBasePublishersStatisticsGet
         * @param token the security token, get it from login route (def)
         * @param name  search the name field (def)
         * @param supplier  search the supplier field (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param status  (def)
         * @param c  count per page (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param domain  search the domain field (def)
         * @param p  page number (def)
         * @param kind  (def)
         */
        inventoryBasePublishersStatisticsGet(params: { token?: string; name?: string; supplier?: string; q?: string; from?: string; status?: string; c?: string; to?: string; domain?: string; p?: string; kind?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryBasePublishersStatisticsGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryCreatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryCreatePost(params: { token?: string; payloadData?: ControllersCreateInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryCreatePost(params, options)(fetch, basePath);
        },
        /**
         * inventoryDuplicatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryDuplicatePost(params: { token?: string; payloadData?: ControllersDuplicateInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryDuplicatePost(params, options)(fetch, basePath);
        },
        /**
         * inventoryIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryIdPut(params: { id: string; token?: string; payloadData?: ControllersChangeLabelPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryIdPut(params, options)(fetch, basePath);
        },
        /**
         * inventoryInventoryIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryInventoryIdPatch(params: { id: string; token?: string; payloadData?: ControllersChangeStatusPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryInventoryIdPatch(params, options)(fetch, basePath);
        },
        /**
         * inventoryInventoryListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryInventoryListDefinitionGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryInventoryListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryInventoryListGet
         * @param token the security token, get it from login route (def)
         * @param label  search the label field (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param sort  (def)
         * @param status  (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         */
        inventoryInventoryListGet(params: { token?: string; label?: string; c?: string; p?: string; q?: string; sort?: string; status?: string; from?: string; to?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryInventoryListGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        inventoryPublisherListDefinitionGet(params: { token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListGet
         * @param token the security token, get it from login route (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param name  search the name field (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param kind  (def)
         * @param status  (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param domain  search the domain field (def)
         * @param supplier  search the supplier field (def)
         * @param c  count per page (def)
         */
        inventoryPublisherListGet(params: { token?: string; to?: string; name?: string; p?: string; q?: string; kind?: string; status?: string; from?: string; sort?: string; domain?: string; supplier?: string; c?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListSingleIdDefinitionGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        inventoryPublisherListSingleIdDefinitionGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListSingleIdDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryPublisherListSingleIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param kind  (def)
         * @param p  page number (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param sort  (def)
         * @param status  (def)
         * @param supplier  search the supplier field (def)
         * @param c  count per page (def)
         * @param name  search the name field (def)
         * @param domain  search the domain field (def)
         */
        inventoryPublisherListSingleIdGet(params: { id: string; token?: string; to?: string; kind?: string; p?: string; q?: string; from?: string; sort?: string; status?: string; supplier?: string; c?: string; name?: string; domain?: string; }, options: any = {}) {
            return ControllersApiFp.inventoryPublisherListSingleIdGet(params, options)(fetch, basePath);
        },
        /**
         * inventoryRemovepubIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        inventoryRemovepubIdPatch(params: { id: string; token?: string; payloadData?: ControllersRemoveInventoryPayload; }, options: any = {}) {
            return ControllersApiFp.inventoryRemovepubIdPatch(params, options)(fetch, basePath);
        },
        /**
         * uploadModuleModulePost
         * @param module  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadModuleModulePost(params: { module: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadModuleModulePost(params, options)(fetch, basePath);
        },
        /**
         * uploadVideoIdGet
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         */
        uploadVideoIdGet(params: { id: string; token?: string; }, options: any = {}) {
            return ControllersApiFp.uploadVideoIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationApi - fetch parameter creator
 */
export const LocationApiFetchParamCreator = {
    /**
     * @func
     * locationCitiesProvinceGet
     * @param province  param
     */
    locationCitiesProvinceGet(params: { province: string; }, options: any = {}): FetchArgs {
        // verify required parameter "province" is set
        if (params["province"] == null) {
            throw new Error("Missing required parameter province when calling locationCitiesProvinceGet");
        }
        const baseUrl = `/location/cities/{province}`
            .replace(`{${"province"}}`, `${ params["province"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * locationProvincesCountryIdGet
     * @param countryId  param
     */
    locationProvincesCountryIdGet(params: { countryId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryId" is set
        if (params["countryId"] == null) {
            throw new Error("Missing required parameter countryId when calling locationProvincesCountryIdGet");
        }
        const baseUrl = `/location/provinces/{country_id}`
            .replace(`{${"country_id"}}`, `${ params["countryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationApi - functional programming interface
 */
export const LocationApiFp = {
    /**
     * locationCitiesProvinceGet
     * @param province  (def)
     */
    locationCitiesProvinceGet(params: { province: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCities> {
        // check permission for locationCitiesProvinceGet
        if (permMap.locationCitiesProvinceGet.protected && !AAA.getInstance().hasPerm(permMap.locationCitiesProvinceGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = LocationApiFetchParamCreator.locationCitiesProvinceGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationCountries> {
        // check permission for locationCountriesGet
        if (permMap.locationCountriesGet.protected && !AAA.getInstance().hasPerm(permMap.locationCountriesGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = LocationApiFetchParamCreator.locationCountriesGet(options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: { countryId: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LocationProvinces> {
        // check permission for locationProvincesCountryIdGet
        if (permMap.locationProvincesCountryIdGet.protected && !AAA.getInstance().hasPerm(permMap.locationProvincesCountryIdGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = LocationApiFetchParamCreator.locationProvincesCountryIdGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
};

/**
 * LocationApi - object-oriented interface
 */
export class LocationApi extends BaseAPI {
    /**
     * locationCitiesProvinceGet
     * @param province  (def)
     */
    locationCitiesProvinceGet(params: { province: string; }, options: any = {}) {
        return LocationApiFp.locationCitiesProvinceGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * locationCountriesGet
     */
    locationCountriesGet(options: any = {}) {
        return LocationApiFp.locationCountriesGet(options)(this.fetch, this.basePath);
    }

    /**
     * locationProvincesCountryIdGet
     * @param countryId  (def)
     */
    locationProvincesCountryIdGet(params: { countryId: string; }, options: any = {}) {
        return LocationApiFp.locationProvincesCountryIdGet(params, options)(this.fetch, this.basePath);
    }
}

/**
 * LocationApi - factory interface
 */
export const LocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * locationCitiesProvinceGet
         * @param province  (def)
         */
        locationCitiesProvinceGet(params: { province: string; }, options: any = {}) {
            return LocationApiFp.locationCitiesProvinceGet(params, options)(fetch, basePath);
        },
        /**
         * locationCountriesGet
         */
        locationCountriesGet(options: any = {}) {
            return LocationApiFp.locationCountriesGet(options)(fetch, basePath);
        },
        /**
         * locationProvincesCountryIdGet
         * @param countryId  (def)
         */
        locationProvincesCountryIdGet(params: { countryId: string; }, options: any = {}) {
            return LocationApiFp.locationProvincesCountryIdGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * @func
     * userAddToWhitelabelPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userAddToWhitelabelPost(params: { token?: string; payloadData?: UserAddUserToWhitelabelPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/add-to/whitelabel`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userAdminPasswordChangeIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userAdminPasswordChangeIdPatch(params: { id: string; token?: string; payloadData?: UserChangePass; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userAdminPasswordChangeIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/admin/password/change/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userAvatarPut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userAvatarPut(params: { token?: string; payloadData?: UserAvatarPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/avatar`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userChangeUserStatusIdPatch
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userChangeUserStatusIdPatch(params: { id: string; token?: string; payloadData?: UserChangeUserStatus; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userChangeUserStatusIdPatch");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/change-user-status/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PATCH"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyPost
     * @param payloadData  param
     */
    userEmailVerifyPost(params: { payloadData?: UserVerifyEmailCodePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyResendPost
     * @param payloadData  param
     */
    userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/email/verify/resend`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userEmailVerifyTokenGet
     * @param token  param
     */
    userEmailVerifyTokenGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/email/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userListDefinitionGet
     * @param token the security token, get it from login route param
     */
    userListDefinitionGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/list/definition`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userListGet
     * @param token the security token, get it from login route param
     * @param q  parameter for search param
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param fullName  search the full_name field param
     * @param cellphone  search the cellphone field param
     * @param ssn  search the ssn field param
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z param
     * @param c  count per page param
     * @param p  page number param
     * @param email  search the email field param
     * @param landLine  search the land_line field param
     * @param sort  param
     * @param status  param
     */
    userListGet(params: { token?: string; q?: string; from?: string; fullName?: string; cellphone?: string; ssn?: string; to?: string; c?: string; p?: string; email?: string; landLine?: string; sort?: string; status?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query);
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["fullName"] !== undefined) {
            urlObj.query["full_name"] = params["fullName"];
        }
        if (params["cellphone"] !== undefined) {
            urlObj.query["cellphone"] = params["cellphone"];
        }
        if (params["ssn"] !== undefined) {
            urlObj.query["ssn"] = params["ssn"];
        }
        if (params["to"] !== undefined) {
            urlObj.query["to"] = params["to"];
        }
        if (params["c"] !== undefined) {
            urlObj.query["c"] = params["c"];
        }
        if (params["p"] !== undefined) {
            urlObj.query["p"] = params["p"];
        }
        if (params["email"] !== undefined) {
            urlObj.query["email"] = params["email"];
        }
        if (params["landLine"] !== undefined) {
            urlObj.query["land_line"] = params["landLine"];
        }
        if (params["sort"] !== undefined) {
            urlObj.query["sort"] = params["sort"];
        }
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLoginPost
     * @param payloadData  param
     */
    userLoginPost(params: { payloadData?: UserLoginPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route param
     */
    userLogoutCloseotherGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout/closeother`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userLogoutGet
     * @param token the security token, get it from login route param
     */
    userLogoutGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userMailCheckPost
     * @param payloadData  param
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/mail/check`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordChangeTokenPut
     * @param token  param
     * @param payloadData  param
     */
    userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/change/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordForgetPost
     * @param payloadData  param
     */
    userPasswordForgetPost(params: { payloadData?: UserForgetPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/forget`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyPost
     * @param payloadData  param
     */
    userPasswordVerifyPost(params: { payloadData?: UserForgetCodePayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/password/verify/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPasswordVerifyTokenGet
     * @param token  param
     */
    userPasswordVerifyTokenGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/password/verify/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userPingGet
     * @param token the security token, get it from login route param
     */
    userPingGet(params: { token?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/ping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "GET"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userRegisterPost
     * @param payloadData  param
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload; }, options: any = {}): FetchArgs {
        const baseUrl = `/user/register`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userSearchMailPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userSearchMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/search/mail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userSearchManagersMailPost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userSearchManagersMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/search/managers/mail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userStartImpersonatePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userStartImpersonatePost(params: { token?: string; payloadData?: UserStartImpersonatePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/start-impersonate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userStorePost
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userStorePost(params: { token?: string; payloadData?: UserStorePayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/store`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "POST"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userUpdateIdPut
     * @param id  param
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userUpdateIdPut(params: { id: string; token?: string; payloadData?: UserEditUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userUpdateIdPut");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/update/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * @func
     * userUpdatePut
     * @param token the security token, get it from login route param
     * @param payloadData  param
     */
    userUpdatePut(params: { token?: string; payloadData?: UserUserPayload; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            params["token"] = AAA.getInstance().getToken();
        }
        const baseUrl = `/user/update`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, {method: "PUT"}, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = {"Content-Type": "application/json"};
        params["payloadData"] = removeEmpty(params["payloadData"]);
        if (params["payloadData"]) {
            fetchOptions.body = JSON.stringify(params["payloadData"] || {});
        }
        fetchOptions.headers = assign({
            "token": params["token"],
        }, contentTypeHeader, fetchOptions.headers);

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * userAddToWhitelabelPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAddToWhitelabelPost(params: { token?: string; payloadData?: UserAddUserToWhitelabelPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userAddToWhitelabelPost
        if (permMap.userAddToWhitelabelPost.protected && !AAA.getInstance().hasPerm(permMap.userAddToWhitelabelPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userAddToWhitelabelPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userAdminPasswordChangeIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAdminPasswordChangeIdPatch(params: { id: string; token?: string; payloadData?: UserChangePass; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userAdminPasswordChangeIdPatch
        if (permMap.userAdminPasswordChangeIdPatch.protected && !AAA.getInstance().hasPerm(permMap.userAdminPasswordChangeIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userAdminPasswordChangeIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            console.log(fetchArgs.options);
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userAvatarPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAvatarPut(params: { token?: string; payloadData?: UserAvatarPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userAvatarPut
        if (permMap.userAvatarPut.protected && !AAA.getInstance().hasPerm(permMap.userAvatarPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userAvatarPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userChangeUserStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userChangeUserStatusIdPatch(params: { id: string; token?: string; payloadData?: UserChangeUserStatus; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserChangeUserStatusResult> {
        // check permission for userChangeUserStatusIdPatch
        if (permMap.userChangeUserStatusIdPatch.protected && !AAA.getInstance().hasPerm(permMap.userChangeUserStatusIdPatch.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userChangeUserStatusIdPatch(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userEmailVerifyPost
     * @param payloadData  (def)
     */
    userEmailVerifyPost(params: { payloadData?: UserVerifyEmailCodePayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userEmailVerifyPost
        if (permMap.userEmailVerifyPost.protected && !AAA.getInstance().hasPerm(permMap.userEmailVerifyPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userEmailVerifyResendPost
        if (permMap.userEmailVerifyResendPost.protected && !AAA.getInstance().hasPerm(permMap.userEmailVerifyResendPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyResendPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userEmailVerifyTokenGet
        if (permMap.userEmailVerifyTokenGet.protected && !AAA.getInstance().hasPerm(permMap.userEmailVerifyTokenGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userEmailVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    userListDefinitionGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserListUsersListDefResponse> {
        // check permission for userListDefinitionGet
        if (permMap.userListDefinitionGet.protected && !AAA.getInstance().hasPerm(permMap.userListDefinitionGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userListDefinitionGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userListGet
     * @param token the security token, get it from login route (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param fullName  search the full_name field (def)
     * @param cellphone  search the cellphone field (def)
     * @param ssn  search the ssn field (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param email  search the email field (def)
     * @param landLine  search the land_line field (def)
     * @param sort  (def)
     * @param status  (def)
     */
    userListGet(params: { token?: string; q?: string; from?: string; fullName?: string; cellphone?: string; ssn?: string; to?: string; c?: string; p?: string; email?: string; landLine?: string; sort?: string; status?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserListUsersListResponse> {
        // check permission for userListGet
        if (permMap.userListGet.protected && !AAA.getInstance().hasPerm(permMap.userListGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userListGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: { payloadData?: UserLoginPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userLoginPost
        if (permMap.userLoginPost.protected && !AAA.getInstance().hasPerm(permMap.userLoginPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userLoginPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userLogoutCloseotherGet
        if (permMap.userLogoutCloseotherGet.protected && !AAA.getInstance().hasPerm(permMap.userLogoutCloseotherGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userLogoutCloseotherGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userLogoutGet
        if (permMap.userLogoutGet.protected && !AAA.getInstance().hasPerm(permMap.userLogoutGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userLogoutGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserCheckMailResponse> {
        // check permission for userMailCheckPost
        if (permMap.userMailCheckPost.protected && !AAA.getInstance().hasPerm(permMap.userMailCheckPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userMailCheckPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userPasswordChangePut
        if (permMap.userPasswordChangePut.protected && !AAA.getInstance().hasPerm(permMap.userPasswordChangePut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userPasswordChangeTokenPut
        if (permMap.userPasswordChangeTokenPut.protected && !AAA.getInstance().hasPerm(permMap.userPasswordChangeTokenPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userPasswordChangeTokenPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: { payloadData?: UserForgetPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userPasswordForgetPost
        if (permMap.userPasswordForgetPost.protected && !AAA.getInstance().hasPerm(permMap.userPasswordForgetPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userPasswordForgetPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userPasswordVerifyPost
     * @param payloadData  (def)
     */
    userPasswordVerifyPost(params: { payloadData?: UserForgetCodePayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userPasswordVerifyPost
        if (permMap.userPasswordVerifyPost.protected && !AAA.getInstance().hasPerm(permMap.userPasswordVerifyPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userPasswordVerifyTokenGet
        if (permMap.userPasswordVerifyTokenGet.protected && !AAA.getInstance().hasPerm(permMap.userPasswordVerifyTokenGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userPasswordVerifyTokenGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: { token?: string; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userPingGet
        if (permMap.userPingGet.protected && !AAA.getInstance().hasPerm(permMap.userPingGet.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userPingGet(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userRegisterPost
        if (permMap.userRegisterPost.protected && !AAA.getInstance().hasPerm(permMap.userRegisterPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userRegisterPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userSearchMailPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userSearchMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserUserSearchResp> {
        // check permission for userSearchMailPost
        if (permMap.userSearchMailPost.protected && !AAA.getInstance().hasPerm(permMap.userSearchMailPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userSearchMailPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userSearchManagersMailPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userSearchManagersMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserUserSearchResp> {
        // check permission for userSearchManagersMailPost
        if (permMap.userSearchManagersMailPost.protected && !AAA.getInstance().hasPerm(permMap.userSearchManagersMailPost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userSearchManagersMailPost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userStartImpersonatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStartImpersonatePost(params: { token?: string; payloadData?: UserStartImpersonatePayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userStartImpersonatePost
        if (permMap.userStartImpersonatePost.protected && !AAA.getInstance().hasPerm(permMap.userStartImpersonatePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userStartImpersonatePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userStorePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStorePost(params: { token?: string; payloadData?: UserStorePayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ControllerNormalResponse> {
        // check permission for userStorePost
        if (permMap.userStorePost.protected && !AAA.getInstance().hasPerm(permMap.userStorePost.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userStorePost(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userUpdateIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdateIdPut(params: { id: string; token?: string; payloadData?: UserEditUserPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserEditAdminResp> {
        // check permission for userUpdateIdPut
        if (permMap.userUpdateIdPut.protected && !AAA.getInstance().hasPerm(permMap.userUpdateIdPut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userUpdateIdPut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: { token?: string; payloadData?: UserUserPayload; }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResponseLoginOK> {
        // check permission for userUpdatePut
        if (permMap.userUpdatePut.protected && !AAA.getInstance().hasPerm(permMap.userUpdatePut.resource)) {
            throw new Error("Permission Error");
        }
        const fetchArgs = UserApiFetchParamCreator.userUpdatePut(params, options);
        return (fetchFn: FetchAPI = fetch, basePath: string = BASE_PATH) => {
            return fetchFn(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    return response.json()
                        .then(res => {
                            res.status = response.status;
                            throw res;
                        })
                        .catch((err) => {
                            err.status = response.status;
                            throw err;
                        });
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * userAddToWhitelabelPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAddToWhitelabelPost(params: { token?: string; payloadData?: UserAddUserToWhitelabelPayload; }, options: any = {}) {
        return UserApiFp.userAddToWhitelabelPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userAdminPasswordChangeIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAdminPasswordChangeIdPatch(params: { id: string; token?: string; payloadData?: UserChangePass; }, options: any = {}) {
        console.log(params);
        return UserApiFp.userAdminPasswordChangeIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * userAvatarPut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userAvatarPut(params: { token?: string; payloadData?: UserAvatarPayload; }, options: any = {}) {
        return UserApiFp.userAvatarPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * userChangeUserStatusIdPatch
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userChangeUserStatusIdPatch(params: { id: string; token?: string; payloadData?: UserChangeUserStatus; }, options: any = {}) {
        return UserApiFp.userChangeUserStatusIdPatch(params, options)(this.fetch, this.basePath);
    }

    /**
     * userEmailVerifyPost
     * @param payloadData  (def)
     */
    userEmailVerifyPost(params: { payloadData?: UserVerifyEmailCodePayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userEmailVerifyResendPost
     * @param payloadData  (def)
     */
    userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload; }, options: any = {}) {
        return UserApiFp.userEmailVerifyResendPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userEmailVerifyTokenGet
     * @param token  (def)
     */
    userEmailVerifyTokenGet(params: { token?: string; }, options: any = {}) {
        return UserApiFp.userEmailVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userListDefinitionGet
     * @param token the security token, get it from login route (def)
     */
    userListDefinitionGet(params: { token?: string; }, options: any = {}) {
        return UserApiFp.userListDefinitionGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userListGet
     * @param token the security token, get it from login route (def)
     * @param q  parameter for search (def)
     * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param fullName  search the full_name field (def)
     * @param cellphone  search the cellphone field (def)
     * @param ssn  search the ssn field (def)
     * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
     * @param c  count per page (def)
     * @param p  page number (def)
     * @param email  search the email field (def)
     * @param landLine  search the land_line field (def)
     * @param sort  (def)
     * @param status  (def)
     */
    userListGet(params: { token?: string; q?: string; from?: string; fullName?: string; cellphone?: string; ssn?: string; to?: string; c?: string; p?: string; email?: string; landLine?: string; sort?: string; status?: string; }, options: any = {}) {
        return UserApiFp.userListGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userLoginPost
     * @param payloadData  (def)
     */
    userLoginPost(params: { payloadData?: UserLoginPayload; }, options: any = {}) {
        return UserApiFp.userLoginPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userLogoutCloseotherGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutCloseotherGet(params: { token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutCloseotherGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userLogoutGet
     * @param token the security token, get it from login route (def)
     */
    userLogoutGet(params: { token?: string; }, options: any = {}) {
        return UserApiFp.userLogoutGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userMailCheckPost
     * @param payloadData  (def)
     */
    userMailCheckPost(params: { payloadData?: UserCheckMailPayload; }, options: any = {}) {
        return UserApiFp.userMailCheckPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userPasswordChangePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
        return UserApiFp.userPasswordChangePut(params, options)(this.fetch, this.basePath);
    }

    /**
     * userPasswordChangeTokenPut
     * @param token  (def)
     * @param payloadData  (def)
     */
    userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
        return UserApiFp.userPasswordChangeTokenPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * userPasswordForgetPost
     * @param payloadData  (def)
     */
    userPasswordForgetPost(params: { payloadData?: UserForgetPayload; }, options: any = {}) {
        return UserApiFp.userPasswordForgetPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userPasswordVerifyPost
     * @param payloadData  (def)
     */
    userPasswordVerifyPost(params: { payloadData?: UserForgetCodePayload; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userPasswordVerifyTokenGet
     * @param token  (def)
     */
    userPasswordVerifyTokenGet(params: { token?: string; }, options: any = {}) {
        return UserApiFp.userPasswordVerifyTokenGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userPingGet
     * @param token the security token, get it from login route (def)
     */
    userPingGet(params: { token?: string; }, options: any = {}) {
        return UserApiFp.userPingGet(params, options)(this.fetch, this.basePath);
    }

    /**
     * userRegisterPost
     * @param payloadData  (def)
     */
    userRegisterPost(params: { payloadData?: UserRegisterPayload; }, options: any = {}) {
        return UserApiFp.userRegisterPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userSearchMailPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userSearchMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}) {
        return UserApiFp.userSearchMailPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userSearchManagersMailPost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userSearchManagersMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}) {
        return UserApiFp.userSearchManagersMailPost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userStartImpersonatePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStartImpersonatePost(params: { token?: string; payloadData?: UserStartImpersonatePayload; }, options: any = {}) {
        return UserApiFp.userStartImpersonatePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userStorePost
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userStorePost(params: { token?: string; payloadData?: UserStorePayload; }, options: any = {}) {
        return UserApiFp.userStorePost(params, options)(this.fetch, this.basePath);
    }

    /**
     * userUpdateIdPut
     * @param id  (def)
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdateIdPut(params: { id: string; token?: string; payloadData?: UserEditUserPayload; }, options: any = {}) {
        return UserApiFp.userUpdateIdPut(params, options)(this.fetch, this.basePath);
    }

    /**
     * userUpdatePut
     * @param token the security token, get it from login route (def)
     * @param payloadData  (def)
     */
    userUpdatePut(params: { token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
        return UserApiFp.userUpdatePut(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * userAddToWhitelabelPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userAddToWhitelabelPost(params: { token?: string; payloadData?: UserAddUserToWhitelabelPayload; }, options: any = {}) {
            return UserApiFp.userAddToWhitelabelPost(params, options)(fetch, basePath);
        },
        /**
         * userAdminPasswordChangeIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userAdminPasswordChangeIdPatch(params: { id: string; token?: string; payloadData?: UserChangePass; }, options: any = {}) {
            return UserApiFp.userAdminPasswordChangeIdPatch(params, options)(fetch, basePath);
        },
        /**
         * userAvatarPut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userAvatarPut(params: { token?: string; payloadData?: UserAvatarPayload; }, options: any = {}) {
            return UserApiFp.userAvatarPut(params, options)(fetch, basePath);
        },
        /**
         * userChangeUserStatusIdPatch
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userChangeUserStatusIdPatch(params: { id: string; token?: string; payloadData?: UserChangeUserStatus; }, options: any = {}) {
            return UserApiFp.userChangeUserStatusIdPatch(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyPost
         * @param payloadData  (def)
         */
        userEmailVerifyPost(params: { payloadData?: UserVerifyEmailCodePayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyResendPost
         * @param payloadData  (def)
         */
        userEmailVerifyResendPost(params: { payloadData?: UserVerifyResendPayload; }, options: any = {}) {
            return UserApiFp.userEmailVerifyResendPost(params, options)(fetch, basePath);
        },
        /**
         * userEmailVerifyTokenGet
         * @param token  (def)
         */
        userEmailVerifyTokenGet(params: { token?: string; }, options: any = {}) {
            return UserApiFp.userEmailVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userListDefinitionGet
         * @param token the security token, get it from login route (def)
         */
        userListDefinitionGet(params: { token?: string; }, options: any = {}) {
            return UserApiFp.userListDefinitionGet(params, options)(fetch, basePath);
        },
        /**
         * userListGet
         * @param token the security token, get it from login route (def)
         * @param q  parameter for search (def)
         * @param from  from date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param fullName  search the full_name field (def)
         * @param cellphone  search the cellphone field (def)
         * @param ssn  search the ssn field (def)
         * @param to  to date rfc3339 ex:2002-10-02T15:00:00.05Z (def)
         * @param c  count per page (def)
         * @param p  page number (def)
         * @param email  search the email field (def)
         * @param landLine  search the land_line field (def)
         * @param sort  (def)
         * @param status  (def)
         */
        userListGet(params: { token?: string; q?: string; from?: string; fullName?: string; cellphone?: string; ssn?: string; to?: string; c?: string; p?: string; email?: string; landLine?: string; sort?: string; status?: string; }, options: any = {}) {
            return UserApiFp.userListGet(params, options)(fetch, basePath);
        },
        /**
         * userLoginPost
         * @param payloadData  (def)
         */
        userLoginPost(params: { payloadData?: UserLoginPayload; }, options: any = {}) {
            return UserApiFp.userLoginPost(params, options)(fetch, basePath);
        },
        /**
         * userLogoutCloseotherGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutCloseotherGet(params: { token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutCloseotherGet(params, options)(fetch, basePath);
        },
        /**
         * userLogoutGet
         * @param token the security token, get it from login route (def)
         */
        userLogoutGet(params: { token?: string; }, options: any = {}) {
            return UserApiFp.userLogoutGet(params, options)(fetch, basePath);
        },
        /**
         * userMailCheckPost
         * @param payloadData  (def)
         */
        userMailCheckPost(params: { payloadData?: UserCheckMailPayload; }, options: any = {}) {
            return UserApiFp.userMailCheckPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userPasswordChangePut(params: { token?: string; payloadData?: UserChangePassword; }, options: any = {}) {
            return UserApiFp.userPasswordChangePut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordChangeTokenPut
         * @param token  (def)
         * @param payloadData  (def)
         */
        userPasswordChangeTokenPut(params: { token?: string; payloadData?: UserCallBackPayload; }, options: any = {}) {
            return UserApiFp.userPasswordChangeTokenPut(params, options)(fetch, basePath);
        },
        /**
         * userPasswordForgetPost
         * @param payloadData  (def)
         */
        userPasswordForgetPost(params: { payloadData?: UserForgetPayload; }, options: any = {}) {
            return UserApiFp.userPasswordForgetPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyPost
         * @param payloadData  (def)
         */
        userPasswordVerifyPost(params: { payloadData?: UserForgetCodePayload; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyPost(params, options)(fetch, basePath);
        },
        /**
         * userPasswordVerifyTokenGet
         * @param token  (def)
         */
        userPasswordVerifyTokenGet(params: { token?: string; }, options: any = {}) {
            return UserApiFp.userPasswordVerifyTokenGet(params, options)(fetch, basePath);
        },
        /**
         * userPingGet
         * @param token the security token, get it from login route (def)
         */
        userPingGet(params: { token?: string; }, options: any = {}) {
            return UserApiFp.userPingGet(params, options)(fetch, basePath);
        },
        /**
         * userRegisterPost
         * @param payloadData  (def)
         */
        userRegisterPost(params: { payloadData?: UserRegisterPayload; }, options: any = {}) {
            return UserApiFp.userRegisterPost(params, options)(fetch, basePath);
        },
        /**
         * userSearchMailPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userSearchMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}) {
            return UserApiFp.userSearchMailPost(params, options)(fetch, basePath);
        },
        /**
         * userSearchManagersMailPost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userSearchManagersMailPost(params: { token?: string; payloadData?: UserSearchUserPayload; }, options: any = {}) {
            return UserApiFp.userSearchManagersMailPost(params, options)(fetch, basePath);
        },
        /**
         * userStartImpersonatePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userStartImpersonatePost(params: { token?: string; payloadData?: UserStartImpersonatePayload; }, options: any = {}) {
            return UserApiFp.userStartImpersonatePost(params, options)(fetch, basePath);
        },
        /**
         * userStorePost
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userStorePost(params: { token?: string; payloadData?: UserStorePayload; }, options: any = {}) {
            return UserApiFp.userStorePost(params, options)(fetch, basePath);
        },
        /**
         * userUpdateIdPut
         * @param id  (def)
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userUpdateIdPut(params: { id: string; token?: string; payloadData?: UserEditUserPayload; }, options: any = {}) {
            return UserApiFp.userUpdateIdPut(params, options)(fetch, basePath);
        },
        /**
         * userUpdatePut
         * @param token the security token, get it from login route (def)
         * @param payloadData  (def)
         */
        userUpdatePut(params: { token?: string; payloadData?: UserUserPayload; }, options: any = {}) {
            return UserApiFp.userUpdatePut(params, options)(fetch, basePath);
        },
    };
};

